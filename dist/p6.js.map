{"version":3,"sources":["webpack:///webpack/bootstrap 7cf8b638b63bd470655f","webpack:///./src/ctypes.js","webpack:///./src/utils.js","webpack:///./flexgl/src/uniform.js","webpack:///./flexgl/src/texture.js","webpack:///./flexgl/src/shader.js","webpack:///./src/derive.js","webpack:///./src/reveal.js","webpack:///./src/interact.js","webpack:///./src/metavis/svg.js","webpack:///./src/metavis/axis.js","webpack:///./src/metavis/scale.js","webpack:///./src/metavis/format.js","webpack:///./index.js","webpack:///(webpack)/buildin/global.js","webpack:///(webpack)/buildin/harmony-module.js","webpack:///./src/pipeline.js","webpack:///./src/allocate.js","webpack:///./src/output.js","webpack:///./src/initialize.js","webpack:///./flexgl/src/flexgl.js","webpack:///./flexgl/src/resource.js","webpack:///./flexgl/src/attribute.js","webpack:///./flexgl/src/varying.js","webpack:///./flexgl/src/subroutine.js","webpack:///./flexgl/src/program.js","webpack:///./flexgl/src/framebuffer.js","webpack:///./src/compile.js","webpack:///./src/aggregate.js","webpack:///./src/cache.js","webpack:///./src/match.js","webpack:///./src/extent.js","webpack:///./src/visualize.js","webpack:///./src/color.js","webpack:///./src/gradients.js","webpack:///./src/colorhex.js","webpack:///./src/render.js","webpack:///./src/encode.js","webpack:///./src/metavis/brush.js","webpack:///./src/metavis/layout.js","webpack:///./src/metavis/chart.js","webpack:///./src/arrays.js","webpack:///./src/metavis/legend.js","webpack:///./src/cstore.js","webpack:///./src/ajax.js","webpack:///./src/parse.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;AC7DA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAaA;;;;;;;;;;;;ACtBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;ACfA;;AAEA,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,yBAAyB;AAC5E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mDAAmD,yBAAyB;AAC5E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;;;AAGA;AACA;;;;;;;;;;AChGA;;AAEA;;AAEA,uDAAuD;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;ACpIA;;AAEA,qDAAqD;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA,8DAA8D,MAAM;AACpE,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAA+D;;AAE/D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,aAAa;AACb;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AClOA;;AAEA,mBAAmB;AACnB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iEAAiE;AACjE,KAAK;;AAEL,0BAA0B;;AAE1B;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,iBAAiB,GAAG;AAChE;;AAEA;AACA;;;;;;;;;;ACrKA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3GA;AACA;AACA;;AAEA;;AAEA;AACA,2CAA2C;AAC3C;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;ACtLA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,kCAAkC;AAClC,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACtIA;;AAEA;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qCAAqC;AAC/F;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA,aAAa;AACb,sCAAsC,eAAe;AACrD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,uCAAuC;AAC1D;;AAEA;;AAEA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;;AAGb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;ACrQA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC,SAAS;AACT;AACA;AACA,gCAAgC;AAChC,SAAS;AACT;AACA;AACA;;AAEA,gCAAgC;;AAEhC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC;AAChC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AC7EY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sEAAsE,IAAI;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6B;;;;;;;ACnBA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB;AACrB,sBAAsB;AACtB;AACA,sBAAsB;AACtB,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,0DAA0D;AAClG;AACA,mDAAmD;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,iBAAiB;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA,uDAAuD;AACvD;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;AC5ZiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA,KAAK;AACL;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AC5NA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,2BAA2B;AACtD,+BAA+B,2BAA2B;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;AChEA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA,sBAAsB,yCAAyC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;;AAEA;;AAEA,qDAAqD;AACrD,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,MAAM;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qCAAqC;;AAErC;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,MAAM;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,MAAM;AACtB,gBAAgB,MAAM;AACtB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,MAAM;AACtB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;;;AChSA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;ACrDA;;AAEA,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kEAAkE;AAClE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;ACnDA;;AAEA,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;;AAEA;AACA;;;;;;;;;ACzBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;AC7BA;;AAEA;;AAEA;AACA;AACA,eAAe;AACf,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACtFA;;AAEA;;AAEA,+DAA+D;AAC/D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACxBiB;;AAEjB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,SAAS;AACT;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA,mEAAmE,gCAAgC;AACnG,8DAA8D,0BAA0B,EAAE;AAC1F,wDAAwD,eAAe,EAAE;;;AAGzE;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gDAAgD;AACxF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;;;;;;;;ACjVA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,iBAAiB;;AAElE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4CAA4C,iBAAiB;AAC7D;;AAEA;AACA;;;;;;;;AC9DA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,iCAAiC;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+BAA+B,EAAE;AAC3E,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA,sCAAsC;AACtC;AACA,SAAS;;;AAGT;AACA;AACA,2BAA2B;AAC3B;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oDAAoD,iBAAiB;AACrE;AACA;AACA,yCAAyC,sCAAsC;AAC/E;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACzQA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,sCAAsC,qCAAqC;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,yBAAyB;AACnD,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,sCAAsC,wCAAwC;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvPkC;AACjB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;AC7IA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnMA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mFAAmF,sBAAsB;AACzG;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;AC3HA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA,yBAAyB,SAAS;AAClC,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;ACxIA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc,qCAAqC;AACnD;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;;AAEA;AACA;AACA;AACA,wCAAwC,qCAAqC;AAC7E,mCAAmC,wBAAwB;AAC3D,mCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iDAAiD,qBAAqB,eAAe;AACrF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qCAAqC;AAC3E;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAA0D,EAAE;AACpF;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;AACT;AACA,wBAAwB,kBAAkB;AAC1C,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACnQA;AAAA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,sBAAsB;AAC/D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,uBAAuB,UAAU;AACjC;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;AACA;;AAEA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;;;;;;;;;;;;ACvOA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,qCAAqC,qCAAqC;AAC1E,gCAAgC;AAChC;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,qEAAmB,+CAA+C;AAClE;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA,KAAK;AACL,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA,SAAS;AACT;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACxJA;AACA;AACA,4DAA4D;AAC5D,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,gDAAgD;AAChD,8CAA8C;AAC9C,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAmB;AAC5D,qBAAqB;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,S;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0CAA0C,8BAA8B;AACxE,SAAS;AACT;AACA;AACA;AACA;AACA,0CAA0C,kCAAkC;AAC5E,SAAS;AACT;AACA;AACA;AACA,0CAA0C,kCAAkC;AAC5E,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;;;AAGA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA,2BAA2B,WAAW;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACvRA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ","file":"p6.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 12);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7cf8b638b63bd470655f","const int      = Int32Array;\nconst short    = Int16Array;\nconst float    = Float32Array;\nconst double   = Float64Array;\nconst string   = Uint16Array;\nconst time     = Float64Array;\nconst temporal = Float64Array;\nconst integer  = Int32Array;\nconst numeric  = Float32Array;\nconst nominal  = Uint16Array;\n\nexport {\n    int,\n    short,\n    float,\n    double,\n    string,\n    time,\n    temporal,\n    integer,\n    numeric,\n    nominal\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ctypes.js\n// module id = 0\n// module chunks = 0","import * as ctypes from './ctypes';\n\nexport function seq(dtype, start, end, interval) {\n    var step = interval || 1,\n        size = (end - start) / step + 1,\n        buf;\n\n    buf = new ctypes[dtype](size);\n    for (var i = 0; i < size; i++) {\n        buf[i] = start + i * step;\n    }\n    return buf;\n}\n\nexport let seqInt = seq.bind(null, \"int\");\nexport let seqFloat = seq.bind(null, \"float\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 1\n// module chunks = 0","export default function Uniform(glContext, name, type, data) {\n\n    var uniform = (this instanceof Uniform) ? this : {},\n        ctx = glContext;\n\n    function serializeArray(arrayOfArray) {\n        var sa = [];\n        arrayOfArray.forEach(function(a){\n            sa = sa.concat(a);\n        })\n        return sa;\n    }\n\n    function setUniform() {\n        var type = this.type,\n            location = this.location,\n            size = this.size,\n            data = this.data;\n\n        if(Array.isArray(data)) {\n            var hasArray = data.filter(function(d){return Array.isArray(d);});\n            if(hasArray)\n                data = serializeArray(data);\n        }\n\n        if((type == 'float' || type == 'int') && !Array.isArray(data) && !ArrayBuffer.isView(data))\n            data = [data];\n\n        var buf;\n        if (type.slice(0,3) == 'vec' || type == 'float') {\n            buf = new Float32Array(data);\n            ctx['uniform' + size + 'fv'](location, buf);\n        } else if(type.slice(0,4) == 'ivec' || type == 'int'){\n            buf = new Int32Array(data);\n            ctx['uniform' + size + 'iv'](location, buf);\n        } else if(type.slice(0,3) == 'mat') {\n            buf = new Float32Array(data);\n            ctx['uniformMatrix' + size + 'fv'](location, false, buf);\n        } else if(type == 'sampler2D') {\n            if(data.hasOwnProperty('resourceType') && data.resourceType == 'texture') {\n                ctx.activeTexture(ctx.TEXTURE0 + data.index);\n                ctx.bindTexture(ctx.TEXTURE_2D, data.ptr);\n                ctx.uniform1i(location, data.index);\n            }\n        }\n    }\n\n    uniform.create = function(name, type, data) {\n\n        if(Array.isArray(data)) {\n            var hasArray = data.filter(function(d){return Array.isArray(d);});\n            if(hasArray)\n                data = serializeArray(data);\n        }\n\n        uniform[name] = {\n            type: type,\n            name: name,\n            data: data,\n            location: null,\n            size: parseInt(type.slice(3,4)) || parseInt(type.slice(4,5)) || 1\n        };\n\n        uniform[name].link = function(program) {\n            if(typeof this.data !== 'undefined' && this.data !== null) {\n                this.location = ctx.getUniformLocation(program, this.name);\n                setUniform.call(this);\n            }\n            return this;\n        };\n\n        uniform[name].load = function(data) {\n            this.data = data;\n            return this;\n        };\n\n        uniform[name].header = function() {\n            var header = 'uniform ' + this.type + ' ' + this.name,\n                len = 0;\n\n            if(this.type != 'sampler2D') {\n                len = this.data.length / this.size;\n            }\n\n            //TODO: fix declaration for matrix\n            if(len > 1 && type != 'mat4') {\n                header += '[' + len + ']';\n            }\n            return header + ';\\n';\n        };\n\n        return uniform[name];\n    }\n\n\n    return uniform;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flexgl/src/uniform.js\n// module id = 2\n// module chunks = 0","import Uniform from \"./uniform\";\n\nexport default function Texture(glContext) {\n\n    var texture = (this instanceof Texture) ? this : {},\n        ctx = glContext,\n        textureID = 0;\n\n    function setTexture(name, texData) {\n        var type = ctx[texture[name].type.toUpperCase()],\n            format = ctx[texture[name].channel.toUpperCase()],\n            width = texture[name].dim[0],\n            height = texture[name].dim[1];\n\n        texture[name].data = texData;\n\n        ctx.bindTexture(ctx.TEXTURE_2D, texture[name].ptr);\n        ctx.texImage2D(ctx.TEXTURE_2D, 0, format, width, height, 0, format, type, texData);\n        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.NEAREST);\n        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.NEAREST);\n        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);\n        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);\n        ctx.bindTexture(ctx.TEXTURE_2D, null);\n    }\n\n    function updateTexture(name, texData, offset, dim) {\n        var type = ctx[texture[name].type.toUpperCase()],\n            format = ctx[texture[name].channel.toUpperCase()],\n            width = dim[0] || texture[name].dim[0],\n            height = dim[1] || texture[name].dim[1];\n\n        ctx.bindTexture(ctx.TEXTURE_2D, texture[name].ptr);\n        ctx.texSubImage2D(ctx.TEXTURE_2D, 0, offset[0], offset[1], width, height, format, type, texData);\n        ctx.bindTexture(ctx.TEXTURE_2D, null);\n    }\n\n    // TODO: Add support for texture compression\n    // function compressTexture(texData) {\n    //\n    //     var ext = (\n    //       ctx.getExtension(\"WEBGL_compressed_texture_s3tc\") ||\n    //       ctx.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\") ||\n    //       ctx.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\")\n    //     );\n    //\n    //     ctx.compressedTexImage2D(ctx.TEXTURE_2D, 0, ext.COMPRESSED_RGBA_S3TC_DXT3_EXT, texture[name].dim[0], texture[name].dim[1], 0, texData);\n    //     ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);\n    //     ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);\n    // }\n\n    texture.create = function(name, type, dim, channel, data, sampler) {\n        var texIndex = (texture.hasOwnProperty(name)) ? texture[name].index : textureID++;\n        texture[name] = {\n            name: name,\n            index: texIndex,\n            type: type || \"float\",\n            dim: dim || [512, 512],\n            channel: channel || \"alpha\",\n            data: null,\n            location: null,\n            sampler: sampler || null,\n            ptr: ctx.createTexture()\n        };\n\n        // if(data !== null && data.length)\n        setTexture(name, data);\n\n        if (texture[name].sampler === null) {\n            texture[name].sampler = Uniform(ctx).create(name, 'sampler2D', texture[name]);\n        } else {\n            texture[name].sampler.data = texture[name];\n        }\n\n        texture[name].link = function(program) {\n            if (this.data !== null) {\n                // ctx.activeTexture(ctx.TEXTURE0 + this.index);\n                // ctx.bindTexture(ctx.TEXTURE_2D, this.ptr);\n                // this.location = ctx.getUniformLocation(program, this.name);\n                // ctx.uniform1i(this.location, this.index);\n                if (typeof(this.sampler.data) == 'undefined' || this.sampler.data === null)\n                    this.sampler.data = texture[name];\n\n                this.sampler.link(program);\n            }\n            return this;\n        }\n\n        texture[name].load = function(texData) {\n            setTexture(this.name, texData);\n            return this;\n        }\n\n        texture[name].copyFromFBO = function() {\n            ctx.bindTexture(ctx.TEXTURE_2D, this.ptr);\n            ctx.copyTexImage2D(\n                ctx.TEXTURE_2D,\n                0,\n                ctx.RGBA,\n                0,\n                0,\n                this.dim[0],\n                this.dim[1],\n                0\n            );\n            ctx.bindTexture(ctx.TEXTURE_2D, null);\n        }\n\n        texture[name].update = function(texData, offset, dim) {\n            updateTexture(this.name, texData, offset, dim);\n            return this;\n        }\n\n        texture[name].resize = function(dim, data) {\n            this.dim = dim;\n            setTexture(this.name, data);\n        }\n\n        texture[name].delete = function() {\n            glContext.deleteTexture(this.ptr);\n        }\n\n        texture[name].header = function() {\n            if (this.name == this.sampler.name)\n                return 'uniform sampler2D ' + this.sampler.name + ';\\n';\n            else\n                return '';\n        }\n\n        return texture[name];\n    }\n\n    return texture;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flexgl/src/texture.js\n// module id = 3\n// module chunks = 0","export default function Shader(glContext, glResource) {\n    \n    var shader = (this instanceof Shader) ? this : {},\n        ctx = glContext,\n        resource = glResource,\n        parameters = ctx._dict || {};\n\n    shader.vertex = {};\n    shader.fragment = {};\n\n    var shaderType = {\n        vertex: ctx.VERTEX_SHADER,\n        fragment: ctx.FRAGMENT_SHADER\n    };\n\n    // Convert JS functions to GLSL codes\n    function toGLSL(returnType, name, fn){\n\n        var glsl = returnType + ' ' +\n            name + '(' + applyEnvParameters(fn.toString())\n            .replace(\n                /var\\s+([\\w|\\d]+)\\s*=\\s*new\\s+([\\w|\\d]+)\\((.*)\\)/g,\n                function(expr, name, dtype, value){\n                    var parts;\n                    if(value)\n                        parts = [dtype.toLowerCase(), name, '=', value];\n                    else\n                        parts = [dtype.toLowerCase(), name];\n\n                    return parts.join(' ')\n                }\n            )\n            .replace(/for\\s*\\(\\s*var\\s+/g, 'for(int ')\n            .replace(/var\\s/g, 'float ')\n            .replace(/this./g, '')\n            .replace(/\\$(.*)\\((.*)\\)\\s*(=|;)/g, \"$1 $2 $3\");\n            // .replace(/\\$(.*?)\\./g, \"$1 \")\n\n        if(name == \"main\") {\n            glsl = glsl.replace(/function.*\\(\\s*([\\s\\S]*?)\\s*{/, '){') + \"\\n\";\n        } else {\n            var args = glsl.match(/function.*\\(\\s*([\\s\\S]*?)\\s*\\)/)[1];\n\n            if(args != \"\") {\n                args = args.replace(/\\$([\\w|\\d]+)_/g, \"$1 \");\n            }\n            glsl = glsl\n                .replace(/function.*\\(\\s*([\\s\\S]*?)\\s*\\)/, args+')') + \"\\n\";\n        }\n        return glsl;\n    }\n\n    //set parameters in JS functions before converting to GLSL codes\n    function applyEnvParameters(str){\n        //find all $(...) and replace them with parameters\n        var envParam = Object.keys(parameters);\n        if(envParam.length > 0){\n            var re = new RegExp(\"\\\\$\\\\((\"+envParam.join(\"|\")+\")\\\\)\",\"g\");\n            str = str.replace(re, function(matched){\n                return parameters[matched.slice(2,matched.length-1)];\n            });\n        }\n\n        // Make uniforms to be used as parameters in shaders, like $(uniformName)\n        // var envUniforms = Object.keys(resource.uniform);\n        // re = new RegExp(\"\\\\$\\\\((\"+envUniforms.join(\"|\")+\")\\\\)\",\"g\");\n        // str = str.replace(re, function(matched){\n        //     return resource.uniform[matched.slice(2,matched.length-1)].data;\n        // });\n\n        return str;\n    }\n\n    function compile(shaderType, shaderSource) {\n        if (shaderType !== ctx.VERTEX_SHADER && shaderType !== ctx.FRAGMENT_SHADER) {\n            throw (\"Error: unknown shader type\");\n        }\n        var _shader = ctx.createShader(shaderType);\n        ctx.shaderSource(_shader, shaderSource);\n        ctx.compileShader(_shader);\n\n        // Check the compile status, get compile error if any\n        var compiled = ctx.getShaderParameter(_shader, ctx.COMPILE_STATUS);\n        if (!compiled) {\n            var lastError = ctx.getShaderInfoLog(_shader);\n            console.log(shaderSource + '\\n ====================================================');\n            throw new Error(\"Error compiling shader '\" + _shader + \"':\" + lastError);\n\n            ctx.deleteShader(_shader);\n            return null;\n        }\n\n        return _shader;\n    }\n\n    function getDeps(fn) {\n        var deps = [],\n            sourceCode = fn.toString(),\n            shaderArgs = sourceCode.match(/function\\s.*?\\(([^)]*)\\)/),\n            args = (shaderArgs !== null && shaderArgs.length) ? shaderArgs[1] : [];\n        // args = args.replace(/(?:\\r\\n|\\r|\\n|\\s)/g, '');\n        //\n        if(args.length) {\n            deps = args.split(',').map(function(arg) {\n                return arg.replace(/\\/\\*.*\\*\\//, '').trim();\n            }).filter(function(arg) {\n                return arg;\n            });\n        }\n\n        var extraDeps = getExtraDeps(sourceCode);\n        if(extraDeps.length) {\n            deps = deps.concat(extraDeps\n            .filter(function(d){\n                return deps.indexOf(d) === -1;\n            }))\n        }\n\n        return deps;\n    }\n\n    function getExtraDeps(fnString) {\n        var extraDeps = fnString.match(/this\\.(\\w+)/g);\n        if(extraDeps !== null) {\n            extraDeps = extraDeps.map(function(d){\n                return d.slice(5);\n            });\n        }\n        return extraDeps || [];\n    }\n\n    function declareDep(dep) {\n        var res = resource.get(dep);\n        if(typeof res === 'undefined')\n            throw new Error('Resource/dependence \"' + dep + '\" is not found.');\n        if(res.resourceType == 'subroutine')\n            return toGLSL(res.type, res.name, res.fn);\n        else\n            return res.header();\n    }\n\n    function uniqueDeps(deps) {\n        var names = {};\n        deps.forEach(function(d, i){\n            names[d] = i;\n        });\n\n        return Object.keys(names);\n    }\n\n    shader.create = function(arg, fn){\n        var option = arg || {},\n            name = option.name || \"default\",\n            type = option.type || \"vertex\",\n            deps = option.require || option.deps || [],\n            precision = option.precision || \"high\",\n            debug = option.debug || false,\n            main = option.main || fn || function() {};\n\n        var shaderSource = 'precision ' + precision + 'p float;\\n';\n\n        if(deps.length === 0) deps = uniqueDeps(getDeps(main));\n\n        //get dependence from subroutines if any\n        var extraDeps = [],\n            subRoutines = [];\n\n        deps.forEach(function(dep){\n            var res = resource.get(dep);\n            if(typeof res == 'undefined') {\n                console.log(dep);\n                throw Error ('Error! Undefined variable in shader: '+  dep.name);\n            }\n            if(res.resourceType == 'subroutine') {\n                subRoutines.push(res.name);\n                var subDeps = getExtraDeps(res.fn.toString());\n                if(subDeps.length) {\n                    //TODO: make this recursive to check all subroutine deps\n                    subDeps.forEach(function(sdep){\n                        var sres = resource.get(sdep);\n                        if(sres.resourceType == 'subroutine')\n                            extraDeps = extraDeps.concat(getExtraDeps(sres.fn.toString()));\n                    })\n\n                    extraDeps = extraDeps.concat(subDeps);\n                }\n            }\n        })\n\n        if(extraDeps.length) {\n            var allDeps = extraDeps\n            // .filter(function(d){\n            //     return deps.indexOf(d) === -1;\n            // })\n            .concat(deps.filter(function(d){\n                return subRoutines.indexOf(d) === -1;\n            }))\n            .concat(subRoutines);\n\n            deps = uniqueDeps(allDeps);\n        }\n\n\n        if(Array.isArray(deps)){\n            deps.forEach(function(dep){\n                shaderSource += declareDep(dep);\n            });\n        } else if(typeof(deps) == 'object') {\n            Object.keys(deps).forEach(function(resourceType){\n                deps[resourceType].forEach(function(dep){\n                    shaderSource += declareDep(dep);\n                });\n            })\n        }\n\n        shaderSource += toGLSL('void', 'main', main);\n        if(debug)\n            console.log(shaderSource);\n        var _shader = compile(shaderType[type], shaderSource);\n        _shader._shaderType = shaderType[type];\n        _shader.deps = deps;\n        _shader.source = shaderSource;\n        shader[type][name] = _shader;\n        return _shader;\n    }\n\n    return shader;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flexgl/src/shader.js\n// module id = 4\n// module chunks = 0","\nexport default function derive($p, spec) {\n\n    var derive = {},\n        dataDimension = $p.uniform.uDataDim.data,\n        deriveMax = $p.uniform.uDeriveCount.data,\n        derivedFields = Object.keys(spec);\n\n    var fields = $p.fields;\n\n    var marco = \"\\t\";\n\n    derivedFields.forEach(function(d, i){\n        var re = new RegExp(\"(\"+fields.join(\"|\")+\")\",\"g\");\n        // var formula = spec[d].replace(/@([\\w|\\d|_]+)/g, function(matched){\n        var formula = spec[d].replace(re, function(matched){\n            // console.log(matched);\n            var index = fields.indexOf(matched);\n            return 'this.getData('  + index + ', pos.x, pos.y)';\n        });\n        marco += 'if (index == ' + i + ') return ' + formula + \"; \\n \\telse \";\n    });\n\n    marco += \" return 0.0;\";\n\n    $p.uniform(\"uOptMode\", \"float\", 0)\n        .uniform(\"uDeriveId\", \"int\", 0)\n        .subroutine(\"getDerivedValue\", \"float\", new Function(\"$int_index\", \"$vec2_pos\", marco));\n\n\n    function vertexShader() {\n        gl_PointSize = 1.0;\n\n        var i, j;\n\n        i = (this.aDataIdx+0.5) / this.uDataDim.x;\n        j = (this.aDataIdy+0.5) / this.uDataDim.y;\n\n        this.vResult = this.getDerivedValue(this.uDeriveId, vec2(i, j));\n        if(this.uFilterFlag == 1) {\n            if(texture2D(this.fFilterResults, vec2(i, j)).a == 0.0)\n                this.vResult = 0.0;\n        }\n        var x, y;\n        if(this.uOptMode == 0.0){\n            x = 0.5;\n            y = 0.5;\n        } else {\n            x = i * 2.0 - 1.0;\n            y = j * 2.0 - 1.0;\n        }\n\n        gl_Position = vec4(x, y, 0.0, 1.0);\n    }\n\n    function fragmentShader() {\n        if(this.vResult == 0.0) discard;\n        if(this.uOptMode > 0.0 || this.vResult >= 0.0)\n            gl_FragColor = vec4(0.0, 0.0, 1.0, this.vResult);\n        else\n            gl_FragColor = vec4(-1.0, this.vResult, 0.0, 0.0);\n    }\n\n    var vs = $p.shader.vertex(vertexShader),\n        fs = $p.shader.fragment(fragmentShader),\n        gl = $p.createProgram(\"derive\", vs, fs);\n\n    // gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n    // gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n    // gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n    // gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n\n    function _execute() {\n\n        var gl = $p.program(\"derive\");\n        $p.framebuffer.enableRead(\"fFilterResults\");\n        $p.bindFramebuffer(\"fDerivedValues\");\n        gl.disable(gl.CULL_FACE);\n        gl.disable(gl.DEPTH_TEST);\n        gl.enable( gl.BLEND );\n        gl.blendFunc( gl.ONE, gl.ONE );\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n\n        // $p.uniform.uDeriveCount = deriveFieldCount;\n        var deriveDomains = [];\n        derivedFields.forEach(function(d, i){\n            $p.uniform.uDeriveId = i;\n            gl.clearColor( 0.0, 0.0, 0.0, 0.0 );\n            gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n            gl.viewport(0, 0, 1,  1);\n\n            var result = new Float32Array(8);\n\n            gl.blendEquation(gl.MAX_EXT);\n            gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n            // gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, max);\n\n            gl.viewport(1, 0, 1,  1);\n            gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n\n            gl.blendEquation(gl.MIN_EXT);\n            gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n            gl.readPixels(0, 0, 2, 1, gl.RGBA, gl.FLOAT, result);\n\n            var minValue = (result[4] < 0) ? result[5] : result[7],\n                maxValue = (result[2] > 0) ? result[3] : result[1];\n            deriveDomains[i] = [minValue, maxValue];\n\n            // deriveDomains[i] = [Math.min(min[0], min[3]), Math.max(max[0], max[3])];\n        });\n        gl.viewport(0, 0, dataDimension[0], dataDimension[1]*deriveMax);\n        gl.disable( gl.BLEND );\n        gl.clearColor( 0.0, 0.0, 0.0, 0.0 );\n        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n\n        $p.uniform.uOptMode = 1.0;\n\n        derivedFields.forEach(function(d, i){\n            $p.uniform.uDeriveId = i;\n            gl.viewport(0, dataDimension[1]*i, dataDimension[0], dataDimension[1]);\n            gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n        });\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return deriveDomains;\n    }\n\n    derive.execute = function(spec) {\n        var derivedFields = Object.keys(spec);\n        var newDerivedDomains = _execute();\n        if(!$p._update) {\n            newDerivedDomains.forEach(function(d, i) {\n                var fieldId = $p.fields.indexOf(derivedFields[i]);\n                if(fieldId === -1) {\n                    $p.fields.push(derivedFields[i]);\n                    fieldId = $p.fields.indexOf(derivedFields[i]);\n                    $p.deriveCount += 1;\n                }\n\n                $p.fieldDomains[fieldId] = d;\n                $p.fieldWidths[fieldId] = d[1] - d[0] + 1;\n            });\n\n            $p.uniform.uFieldDomains.data = $p.fieldDomains;\n            $p.uniform.uFieldWidths.data = $p.fieldWidths;\n        }\n    }\n\n    derive.result = function(arg) {\n        var options = arg || {},\n            offset = options.offset || [0, 0],\n            resultSize = options.size || $p.dataDimension[0]* $p.dataDimension[1],\n            fid = options.fieldId || options.deriveFieldId || 0,\n            rowSize = Math.min(resultSize, $p.dataDimension[0]),\n            colSize = Math.ceil(resultSize/$p.dataDimension[0]);\n\n        var result = new Float32Array(rowSize * colSize * 4);\n        gl.readPixels(0, dataDimension[1]*fid, rowSize, colSize, gl.RGBA, gl.FLOAT, result);\n        return result.filter(function(d, i){ return i%4===3;} ); //return channel alpha in rgba\n    }\n\n    return derive;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/derive.js\n// module id = 5\n// module chunks = 0","\nexport default function reveal($p) {\n    var viewport = $p.viewport,\n        padding = $p.padding;\n\n    $p.uniform('uRevealMode', 'int', 1)\n        .framebuffer(\"offScreenFBO\", \"float\", $p.viewport)\n        .framebuffer(\"visStats\", \"float\", [1, 1]);\n\n    var aViewX = new Float32Array($p.viewport[0]).map((d, i) => i);\n    var aViewY = new Float32Array($p.viewport[1]).map((d, i) => i);\n\n    $p.attribute(\"aViewX\", \"float\", aViewX)\n        .attribute(\"aViewY\", \"float\", aViewY);\n\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aViewX.location, 0);\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aViewY.location, 1);\n\n    var vs = $p.shader.vertex(function(){\n        var i, j;\n        i = (this.aViewX+0.5) / this.uViewDim.x;\n        j = (this.aViewY+0.5) / this.uViewDim.y;\n        this.vColorRGBA = texture2D(this.offScreenFBO, vec2(i, j));\n        gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    });\n\n    var fs = $p.shader.fragment(function() {\n        gl_FragColor = this.vColorRGBA;\n    });\n\n    $p.program(\"post-processing\", vs, fs);\n\n    var vs2 = $p.shader.vertex(function () {\n         gl_Position = vec4(this._square, 0, 1);\n    });\n\n    var fs2 = $p.shader.fragment(function() {\n        var x, y, a;\n        var value = new Vec4();\n        x = (gl_FragCoord.x+0.5) / this.uViewDim.x;\n        y = (gl_FragCoord.y+0.5) / this.uViewDim.y;\n        value = texture2D(this.offScreenFBO, vec2(x, y));\n\n        if(value.a == 0.0) discard;\n        // a = pow(((value.a - this.uDefaultAlpha) / (this.uMaxRGBA.a -this.uDefaultAlpha)), 0.33) * 0.85 + 0.15;\n        a = pow((value.a / this.uMaxRGBA.a), 0.33) * 0.9 + 0.1;\n        // a = value.a / this.uMaxRGBA.a;\n\n        if(this.uRevealMode == 0) {\n            gl_FragColor = vec4(this.uDefaultColor*a, a);\n        } else {\n            gl_FragColor = vec4(texture2D(this.tColorGraident, vec2(1.-a, 1.0)).rgb*this.uDefaultAlpha, this.uDefaultAlpha);\n        }\n    });\n\n    $p.program(\"vis-render\", vs2, fs2);\n\n    return function(options) {\n        var gl,\n            viewIndex = options.viewIndex,\n            viewDim = options.dim,\n            offset = options.offset || [0, 0],\n            padding = options.padding || {left: 0, right: 0, left: 0, right:0};\n\n        if(!$p._update) {\n            $p.framebuffer(\"visStats\", \"float\", [1, 1]);\n            gl = $p.program(\"post-processing\");\n            $p.framebuffer.enableRead(\"offScreenFBO\");\n            $p.bindFramebuffer(\"visStats\");\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aViewX.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aViewY.location, 1);\n            gl.clearColor( 0.0, 0.0, 0.0, 0.0 );\n            gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n            gl.disable(gl.CULL_FACE);\n            gl.disable(gl.DEPTH_TEST);\n            gl.enable( gl.BLEND );\n            gl.blendFunc( gl.ONE, gl.ONE );\n            gl.blendEquation(gl.MAX_EXT);\n            gl.viewport(0, 0, 1, 1);\n            gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0,  viewDim[0], viewDim[1]);\n\n            var max = new Float32Array(4);\n            gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, max);\n            if(max[3] == 0) {\n                max[3] = Math.sqrt($p.dataSize) * Math.log2($p.dataSize);\n            }\n            $p.views[viewIndex].maxRGBA = max;\n        }\n\n        $p.uniform.uMaxRGBA = $p.views[viewIndex].maxRGBA;\n\n        $p.bindFramebuffer(null);\n        gl = $p.program(\"vis-render\");\n        gl.ext.vertexAttribDivisorANGLE($p.attribute._square.location, 0);\n        $p.framebuffer.enableRead(\"offScreenFBO\");\n\n        gl.viewport(\n            offset[0] + padding.left,\n            offset[1] + padding.bottom,\n            viewDim[0] - padding.left - padding.right,\n            viewDim[1] - padding.top - padding.bottom\n        );\n        // gl.blendEquation(gl.FUNC_ADD);\n        gl.disable( gl.BLEND );\n        // gl.clearColor( 0.0, 0.0, 0.0, 0.0 );\n        // gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/reveal.js\n// module id = 6\n// module chunks = 0","\nimport Brush from './metavis/brush';\nexport default function interact($p, options) {\n    var viewTags = options.view || [$p.views[0].id];\n\n    if(!Array.isArray(viewTags)) viewTags = [viewTags];\n\n    var actions = options.actions || options.events || [],\n        condition = options.condition || {},\n        callback = options.callback || function() {};\n\n    if($p._update) return;\n\n    viewTags.forEach(function(viewTag){\n        var vis = $p.views.filter(v=>v.id == viewTag)[0];\n\n        if(!Array.isArray(actions)) {\n            actions = [actions];\n        }\n        var vmap = vis.vmap,\n            p = vis.padding || $p.padding,\n            w = vis.width - p.left - p.right,\n            h = vis.height - p.top - p.bottom;\n\n        var interactor = vis.chart.svg.append(\"g\")\n                .attr(\"class\", \"selector\")\n\n        var rect = interactor.append(\"rect\")\n          .attr(\"x\", 0)\n          .attr(\"y\", 0)\n          .attr(\"width\", w)\n          .attr(\"height\", h)\n          .attr(\"fill-opacity\", 0)\n          .attr(\"stroke\", \"none\");\n\n        var svg = interactor.svg,\n            box = rect.svg.getBoundingClientRect();\n\n        var sx, sy,\n            tx = 0, ty = 0,\n            dy = 1;\n\n        function updatePos(e) {\n            tx += (e.clientX - sx) / dy;\n            ty += (e.clientY - sy) / dy;\n            sx = e.clientX;\n            sy = e.clientY;\n            $p.uniform.uPosOffset.data = [tx / w, ty / h];\n        }\n\n        function getSelection(e) {\n            var dx = e.clientX - box.left;\n            var dy = e.clientY - box.top;\n            var selection = {};\n            if(vmap.x) {\n                selection[vmap.x] = [vis.chart.x.invert(dx)];\n            }\n            if(vmap.y) {\n                selection[vmap.y] = [vis.chart.y.invert(dy)];\n            }\n            return selection;\n        }\n\n        actions.forEach(function(action){\n            if(action == 'brush') {\n                svg.style.cursor = \"crosshair\";\n                var brushOptions = {\n                    container: interactor,\n                    width: w,\n                    height: h\n                };\n\n                if(!Array.isArray(vmap.x) && !Array.isArray(vmap.y)) {\n                    if(!condition.x && !condition.y) {\n                        condition.x = condition.y = true;\n                    }\n                    brushOptions.brush = function(d) {\n                        var selection = {};\n                        if(vmap.x && d.x) selection[vmap.x] = d.x;\n                        if(vmap.y && d.y) selection[vmap.y] = d.y.reverse();\n                        callback(selection);\n                    }\n                    if(condition.x && typeof(vis.chart.x.invert) == 'function')\n                        brushOptions.x = vis.chart.x.invert;\n\n                    if(condition.y && typeof(vis.chart.y.invert) == 'function')\n                        brushOptions.y = vis.chart.y.invert\n\n                    new Brush(brushOptions);\n                }\n\n                var dims = ['x', 'y'],\n                    selections = {};\n\n                dims.forEach(function(dim){\n                    if(Array.isArray(vmap[dim]) && Array.isArray(vis.chart[dim])){\n                        var axisDist = (dim == 'x') ? h : w,\n                            selectors = vis.chart.svg.append('g');\n\n                        axisDist =  axisDist / (vmap[dim].length-1);\n\n                        vmap[dim].forEach(function(d, i) {\n\n                            var axisSelect = selectors.append(\"g\");\n                            if(dim == 'x') {\n                                brushOptions.height = axisDist * 0.2;\n                                axisSelect.translate(0, axisDist * (i - 0.1));\n                                brushOptions.brush = function(range) {\n                                    selections[d] = range[dim];\n                                    callback(selections);\n                                }\n                            } else {\n                                brushOptions.width = axisDist * 0.2;\n                                axisSelect.translate(axisDist * (i - 0.1), 0);\n                                brushOptions.brush = function(range) {\n                                    selections[d] = range[dim].reverse();\n                                    callback(selections);\n                                }\n                            }\n                            brushOptions.container = axisSelect;\n                            brushOptions[dim] = vis.chart[dim][i].invert;\n\n                            new Brush(brushOptions);\n                        });\n                    }\n                })\n            } else if(action == 'zoom') {\n                svg.onmousewheel = function(e) {\n                    sx = e.clientX - box.left;\n                    sy = e.clientY - box.top;\n                    var ny =  dy * Math.exp(e.deltaY / 1000);\n                    var delta = ny - dy;\n                    dy = ny;\n                    $p.uniform.uPosOffset.data = [-sx * delta / w, -sy * delta / h];\n                    $p.uniform.uVisScale.data = [dy, dy];\n\n                    callback();\n                }\n\n            } else if(action == 'pan') {\n                svg.style.cursor = 'move';\n                svg.onmousedown = function(e) {\n                    sx = e.clientX;\n                    sy = e.clientY;\n                    svg.style.cursor = 'move';\n\n                    svg.onmousemove = function(e) {\n                        tx += (e.clientX - sx) / dy;\n                        ty += (e.clientY - sy);\n\n                        callback();\n                    }\n\n                    svg.onmouseup = function(e) {\n                        updatePos(e);\n                        svg.style.cursor = 'default';\n                        svg.onmousemove = null;\n                        svg.onmouseup = null;\n                    }\n                }\n\n            } else if(action == 'click') {\n                svg.onclick = function(e) {\n                    callback(getSelection(e));\n                }\n            } else if(action == 'hover') {\n                svg.onmouseover = function(e) {\n                    callback(getSelection(e));\n                    svg.onmousemove = function(e) {\n                        callback(getSelection(e));\n                    }\n\n                    // svg.onmouseout = function(e) {\n                    //     updatePos(e);\n                    //     svg.style.cursor = 'default';\n                    //     svg.onmousemove = null;\n                    //     svg.onmouseover = null;\n                    // }\n                }\n            }\n        })\n    })\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/interact.js\n// module id = 7\n// module chunks = 0","function setAttr(elem, attr) {\n    for( var key in attr ){\n        var value = attr[key],\n            c = key.match(/[A-Z]/);\n        if(c !== null) key = key.replace(c[0], \"-\"+c[0].toLowerCase())\n        elem.setAttribute(key, value);\n    }\n}\n\nfunction setStyle(elem, style) {\n    for( var key in style ){\n        var value = style[key],\n            c = key.match(/[A-Z]/);\n        if(c !== null) key = key.replace(c[0], \"-\"+c[0].toLowerCase())\n        elem.style[key] = value;\n    }\n}\n\nexport default function Svg(arg){\n    'use strict';\n    var self = (this instanceof Svg) ? this: {},\n        option = arg || {},\n        type = option.type || 'svg',\n        svgNS = 'http://www.w3.org/2000/svg',\n        svg = document.createElementNS(svgNS, type),\n        width = option.width || 400,\n        height = option.height || 300,\n        parent = option.parent || option.container || this.parent,\n        attr = option.attr || {},\n        style = option.style || {},\n        padding = option.padding || {left: 0, right: 0, top: 0, bottom: 0};\n\n    if(type === 'svg') {\n        var defaultAttr = {\n            width   : width + padding.left + padding.right,\n            height  : height + padding.top + padding.bottom,\n            viewBox : [0, 0, width + padding.left + padding.right , height + padding.top + padding.bottom].join(' '),\n            preserveAspectRatio: 'none'\n        };\n        setAttr(svg, defaultAttr);\n    }\n\n    self.innerWidth = function() {\n        return width;\n    }\n\n    self.innerHeight = function() {\n        return height;\n    }\n\n    self.padding = function() {\n        return padding;\n    }\n\n    if(style) setStyle(svg, style);\n    if(attr) setAttr(svg, attr);\n\n    if(parent) {\n        parent = (typeof parent == \"string\") ? document.getElementById(parent) : parent;\n        parent.appendChild(svg);\n    }\n\n    self.svg = svg;\n    self.parent = parent;\n\n    if(self instanceof Svg)\n        publicMethods(Svg.prototype);\n    else\n        publicMethods(self);\n\n    return self;\n};\n\nfunction publicMethods(context) {\n    context.append = function(type, attr, style) {\n        var options = {};\n        options.parent = this.svg;\n        options.type = type;\n        options.attr = attr;\n        options.style = style;\n        return new Svg(options);\n    };\n\n    context.remove = function() {\n        this.parent.removeChild(this.svg);\n    };\n\n    context.attr = function(a, v) {\n        if(typeof(a) == \"object\")\n            setAttr(this.svg, a);\n        else\n            this.svg.setAttribute(a, v);\n\n        return this;\n    }\n\n    context.Attr =  function(a, v) {\n        setAttr(this.svg, a);\n        return this;\n    }\n\n    context.Style =  function(a, v) {\n        setStyle(this.svg, a);\n        return this;\n    }\n\n    context.style = function(a, v) {\n        if(typeof(a) == \"object\")\n            setStyle(this.svg, a);\n        else\n            this.svg.style[a] = v;\n\n        return this;\n    }\n\n    context.css = context.style;\n\n    context.text = function(str){\n        this.svg.appendChild(document.createTextNode(str));\n        return this;\n    };\n\n    context.translate = function(x, y) {\n        var p = this.svg.getAttribute(\"transform\") || \"\";\n        this.svg.setAttribute(\"transform\", p + \"translate(\" + [x,y].join(\",\") + \") \");\n        return this;\n    };\n\n    context.on = function(event, callback) {\n        this.svg.addEventListner(event, callback);\n        return this;\n    }\n\n    return context;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/metavis/svg.js\n// module id = 8\n// module chunks = 0","import Scale from './scale';\n\nexport default function axis(arg) {\n\n    var option      = arg || {},\n        svg         = option.container || option.parent,\n        dim         = option.dim || \"x\",\n        color       = option.color || \"#000\",\n        position    = option.position || 0,\n        align       = option.align || \"\",\n        scale       = option.scale || \"linear\",\n        exponent    = option.exponent || 1,\n        metric      = option.metric || null,\n        domain      = option.domain || [0,1],\n        width       = option.width || svg.innerWidth(),\n        height      = option.height || svg.innerHeight(),\n        padding     = option.padding || svg.padding() || {left: 0, right: 0, top: 0, bottom: 0},\n        range       = option.range || (dim == \"x\") ? [0, width] : [height, 0],\n        styles      = {stroke: color, 'stroke-width': 1},\n        ticks       = option.ticks,\n        tickLength  = option.tickLength || 6,\n        tickPosition = option.tickPosition || false,\n        tickInterval= option.tickInterval || \"auto\",\n        tickAlign = option.tickAlign || \"center\",\n        skipLast = option.skipLast || false,\n        tickFormat  = option.tickFormat || null,\n        grid        = option.grid,\n        format      = option.format || function(_){return _;},\n        visable    = option.visable || true,\n        domainIntervals,\n        labelPos    = null,\n        labelAngle  = option.labelAngle || 0,\n        X = [],\n        Y = [];\n\n    if(typeof(ticks) != \"number\") {\n        ticks = (dim == \"x\") ? Math.ceil(width/50) : Math.ceil(height/50);\n    }\n    var tickLabelAlign = option.tickLabelAlign || \"end\";\n    switch (align) {\n        case \"left\" || \"center\":\n            labelPos = option.labelPos || {x: -tickLength/2, y: -5};\n            tickLabelAlign =  option.tickLabelAlign ||\"end\";\n            break;\n        case \"right\":\n            labelPos = {x: tickLength, y: -5};\n            tickLabelAlign = option.tickLabelAlign || \"start\";\n            if(!tickPosition) tickPosition = [ tickLength/2, 0];\n            break;\n        case \"top\":\n            labelPos = {x: 0, y: 0};\n            tickLabelAlign = \"middle\";\n            if(!tickPosition) tickPosition = [0, -tickLength];\n            break;\n        case \"bottom\" || \"middle\":\n            labelPos = option.labelPos || {x: 0, y: -tickLength*3};\n            tickLabelAlign =  option.tickLabelAlign || \"middle\";\n            break;\n        default:\n            labelPos = option.labelPos || option.labelPosition || {x: 0, y: 0};\n            break;\n    }\n    if(!tickPosition) tickPosition = [0,0];\n\n    function getTickInterval(){\n        var vDomain = Math.abs(domain[1] - domain[0]),\n            intv = vDomain / ticks,\n            pow = Math.ceil(Math.log10(intv)),\n            intv = intv / Math.pow(10, pow);\n\n        if(intv > 0.2 && intv <= 0.25){\n            intv = 0.25;\n        } else if(intv > 0.7 && intv <= 0.75) {\n            intv = 0.75;\n        } else {\n            intv = Math.ceil(intv * 10) / 10;\n        }\n        return intv * Math.pow(10, pow);\n    }\n\n\n    if (scale == \"categorical\" || scale == \"ordinal\") {\n        domainIntervals = function() {\n            var len = domain.length,\n                step = Math.ceil(len / ticks),\n                intervals = [],\n                i;\n            for(i = 0; i < len; i += step) {\n                intervals.push(domain[i])\n            }\n            // if(intervals[i] != domain[len-1]) intervals.push(domain[len-1]);\n\n            return intervals;\n        };\n    } else {\n        var intv;\n\n        if(tickInterval == \"auto\"){\n            intv = getTickInterval();\n\n        } else {\n            if(typeof(tickInterval) == \"number\") {\n                intv = tickInterval;\n            } else {\n                // intv = Math.abs(domain[1] - domain[0]) / ticks;\n                intv = getTickInterval();\n                domain[0] = intv * Math.floor(domain[0]/intv);\n                domain[1] = intv * Math.ceil(domain[1]/intv);\n            }\n        }\n\n        domainIntervals = function() {\n            var di = [];\n\n            if(domain[0] > domain[1]) {\n                domain[0] += intv;\n                for(var i = domain[0]; i > domain[1]; i=i-intv)\n                    di.push(i);\n            } else {\n                for(var i = domain[0]; i < domain[1]; i=i+intv)\n                    di.push(i);\n            }\n\n            if(di[di.length-1]!=domain[1] && !isNaN(domain[1]) && !skipLast){\n\n                if((domain[1] - di[di.length-1]) < 0.4 * intv)\n                    di[di.length-1] = domain[1];\n                else\n                    di.push(domain[1]);\n            }\n            return di;\n        }\n    }\n\n    if (metric === null) {\n\n        var scaleOptions = {\n            align: tickAlign,\n            type: scale,\n            domain: domain,\n            range: range\n        };\n\n        if(scale == \"power\") {\n            scaleOptions.exponent = exponent;\n        }\n\n        metric = Scale(scaleOptions)\n    } else {\n        domain = metric.domain();\n    }\n\n    var axis = svg.append(\"g\");\n\n    if(dim == 'x') {\n        if(!position && align) {\n            position = [0,height/2,height];\n            position = position[[\"top\", \"middle\", \"bottom\"].indexOf(align)];\n        }\n        Y[0] = Y[1] = position;\n        X[0] = 0;\n        X[1] = Math.abs(range[1] - range[0]);\n    } else {\n        if(!position && align) {\n            position = [0, width/2, width];\n            position = position[[\"left\", \"center\", \"right\"].indexOf(align)];\n        }\n        X[0] = X[1] = position;\n        Y[0] = 0;\n        Y[1] = Math.abs(range[1] - range[0]);\n    }\n\n    metric.show = metric.axis = function() {\n        axis.append(\"g\")\n            .append(\"line\")\n            .Attr({x1: X[0], x2: X[1], y1: Y[0], y2: Y[1]})\n            .Style(styles);\n\n        var di = domainIntervals();\n\n        for(var i = 0; i < di.length; i++) {\n            var x1,x2,y1,y2;\n            if(dim == 'x'){\n                x1 = x2 = metric(di[i]) + tickPosition[0];\n                y1 = position + tickPosition[1] + tickLength;\n                y2 = y1 - tickLength;\n            } else {\n                if(scale == \"categorical\" || scale == \"ordinal\")\n                    y1 = y2 = height - metric(di[i]);\n                else\n                    y1 = y2 = metric(di[i]) + tickPosition[1];\n                x1 = position + tickPosition[0] ;\n                x2 = x1 - tickLength;\n            }\n\n            var svgTicks = axis.append(\"g\");\n            svgTicks.append(\"line\", {\n                x1: x1,\n                x2: x2,\n                y1: y1,\n                y2: y2,\n            }, styles);\n\n\n            // if (dim == 'x') tickLabelAlign = \"middle\";\n            // if (dim == 'x' && labelAngle) tickLabelAlign = \"end\";\n\n            var tickLabel = svgTicks.append(\"text\")\n                .Attr({\n                    x: x2 + labelPos.x,\n                    y: y2 - labelPos.y,\n                    // class: \"labels\",\n                    class: \"i2v-axis-label\",\n                    \"font-size\": \"0.9em\",\n                    textAnchor: tickLabelAlign\n                });\n            if(labelAngle) tickLabel.attr(\"transform\", \"rotate(\" + [labelAngle, (x2 + labelPos.x), (y2 - labelPos.y)].join(\",\")+\")\");\n\n            var labelText = (typeof(tickFormat) == \"function\") ? format(tickFormat(di[i])) : format(di[i]) ;\n            // tickLabel.appendChild( document.createTextNode(labelText) );\n            tickLabel.text(labelText);\n\n            if(grid) {\n                var gx1, gx2, gy1, gy2;\n                if(dim == 'x'){\n                    gx1 = gx2 = metric(di[i]);\n                    gy1 = 0;\n                    gy2 =height;\n                } else {\n                    gy1 = gy2 = metric(di[i]);\n                    gx1 = 0;\n                    gx2 = width;\n                }\n                axis.append(\"line\",\n                    {\n                        x1: gx1,\n                        x2: gx2,\n                        y1: gy1,\n                        y2: gy2,\n                        class: \"grid-lines\"\n                    },\n                    {\n                        \"stroke\": color,\n                        // \"stroke-width\": 0.5,\n                        \"stroke-opacity\": 0.33\n                    });\n            }\n        }\n        axis.translate(padding.left, padding.top);\n        return axis;\n    };\n\n    metric.remove = function() {\n        axis.remove();\n    }\n\n    if(visable) {\n        metric.svg = metric.show();\n    }\n\n    return metric;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/metavis/axis.js\n// module id = 9\n// module chunks = 0","export default function Scale(arg) {\n    var option = arg || {},\n        align = option.align || 'center',\n        type = option.type || 'linear',\n        domain = option.domain || [0,1],\n        margin = option.margin || 0,\n        exponent = option.exponent || 1,\n        range = option.range || [0,1];\n\n    function getInterpolateFunction() {\n        //intercepts and slopes for domain and range\n        var d0 = -domain[0] / (domain[1] - domain[0]),\n            d1 = 1 / (domain[1] - domain[0]),\n            r0 = range[0],\n            r1 = range[1] - range[0];\n\n        if(type == \"linear\") {\n            return function(v) { return r0 + (d0 + v * d1) * r1 };\n        } else if(type == \"power\") {\n            d0 = -Math.pow(-d0, exponent);\n            d1 = Math.pow(d1, exponent);\n            return function(v) { return r0 + (d0 + Math.pow(v, exponent) * d1) * r1 };\n        } else if (type == \"log\") {\n            exponent = option.exponent || 10;\n            d0 = -(Math.log(-d0) / Math.log(exponent));\n            d1 = (Math.log(d1) / Math.log(exponent));\n\n            return function(v) { return r0 + (d0 + Math.log(v) / Math.log(exponent) * d1) * r1 };\n\n        } else if(type == \"ordinal\" || type == \"categorical\") {\n            return function(v) {\n                if(align == 'outer')\n                    return r0 + (domain.indexOf(v)) / (domain.length-1) * r1;\n                else\n                    return r0 + (domain.indexOf(v)+0.5) / domain.length * r1;\n            };\n        } else {\n            return function(v) { return v };\n        }\n    }\n\n    var scale = getInterpolateFunction();\n\n    scale.interval = function(ticks) {\n        if (type == \"ordinal\" || type == \"categorical\") {\n            return (1 / domain.length * Math.abs(range[1] - range[0]));\n        } else {\n            var s = Math.pow(10, Math.floor(Math.log10(Math.abs(range[1] - range[0])))-1);\n            return Math.floor( Math.abs(range[1] - range[0]) / (ticks * s) )  * s;\n        }\n    };\n\n    scale.domainLength = function() {\n        if(type == \"linear\")\n            return Math.abs(domain[1] - domain[0]);\n        else if(type == \"ordinal\" || type == \"categorical\")\n            return domain.length;\n    };\n\n    scale.rangeLength = function() {\n        return Math.abs(range[1] - range[0]);\n    };\n\n    scale.invert = function(r) {\n        if(type == \"linear\") {\n            return domain[0] + (r - range[0]) / (range[1] - range[0]) * (domain[1] - domain[0]);\n        } else if(type == \"ordinal\" || type == \"categorical\") {\n            var intv = intv = r / scale.rangeLength();\n            return domain[Math.floor(intv * (domain.length))];\n        }\n    }\n\n    scale.domain = function() {\n        return domain;\n    }\n\n    return scale;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/metavis/scale.js\n// module id = 10\n// module chunks = 0","import {seq} from '../arrays';\n\nexport default function printformat(spec) {\n    return function(value){\n        if(typeof value !== \"number\") return value;\n        var ret,\n            convert,\n            numericSymbols = ['y', 'z', 'a', 'f', 'p', 'n', '', 'm', '', 'k', 'M','G', 'T', 'P', 'E', 'Z', 'Y'],\n            n = seq(-24,24,3),\n            i = numericSymbols.length-1,\n            parts,\n            precision = spec.match(/\\d+/)[0] || 3,\n            number = Number(value),\n            exp,\n            suffix;\n\n        if(spec[spec.length-1] == 's')\n            precision--;\n\n        parts = number.toExponential(precision).toString().match(/^(-{0,1})(\\d+)\\.?(\\d*)[eE]([+-]?\\d+)$/);\n        exp = parseInt(parts[4]) || 0;\n\n        while (i--) {\n            if (exp >= n[i]) {\n                if(i==7 && (exp-n[i]) > 1) {\n                    // console.log(exp-n[i]);\n                    suffix = numericSymbols[i+1];\n                    exp -= n[i+1];\n                    break\n                } else {\n                    suffix = numericSymbols[i];\n                    exp -= n[i];\n                    break;\n                }\n            }\n        }\n        ret = parseFloat(parts[1] + parts[2] + '.' + (parts[3]||0) + 'e' + exp.toString());\n        return ret.toString() + suffix;\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/metavis/format.js\n// module id = 11\n// module chunks = 0","import p6 from './src/pipeline';\nimport cstore from './src/cstore';\nimport  * as ctypes  from './src/ctypes';\nimport * as ajax from './src/ajax';\nimport parse     from './src/parse';\n\nvar root = typeof self == 'object' && self.self === self && self ||\n           typeof global == 'object' && global.global === global && global ||\n           this;\n\nroot.p6 = p6;\nroot.p6.ajax = ajax;\nroot.p6.cstore = cstore;\nroot.p6.ctypes = ctypes;\nroot.p6.parse = parse;\n\nexport default root.p6;\n\nif(typeof module != 'undefined' && module.exports)\n    module.exports = root.p6;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.js\n// module id = 12\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 13\n// module chunks = 0","module.exports = function(originalModule) {\r\n\tif(!originalModule.webpackPolyfill) {\r\n\t\tvar module = Object.create(originalModule);\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"exports\", {\r\n\t\t\tenumerable: true,\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/harmony-module.js\n// module id = 14\n// module chunks = 0","import allocate  from './allocate';\nimport output    from './output';\nimport initialize    from './initialize';\nimport compile   from './compile';\nimport optDerive from './derive';\nimport interact  from './interact';\n\nexport default function pipeline(options) {\n    var $p = initialize(options);\n    $p.views = [];\n    $p.interactions = [];\n    \n    $p.visualization = null;\n    $p.deriveMax = options.deriveMax || 4;\n    $p._responseType = 'unselected';\n    $p._update = false;\n\n    $p.getResult = function() {};\n\n    var pipeline = {},\n        registers = {},\n        profiles  = [],\n        operation = {},\n        response = {},\n        optID = 0;\n\n    function addToPipeline(opt, arg) {\n        if( !$p._update) {\n            var spec = {};\n            spec[opt] = arg;\n            $p.pipeline.push(spec);\n            return optID++;\n        } else {\n            return -1;\n        }\n    }\n\n    pipeline.ctx = $p.ctx;\n\n    pipeline.data = function(dataOptions) {\n        allocate($p, dataOptions);\n        operation = compile($p);\n        if(!$p.hasOwnProperty('fieldDomains')) {\n            var dd = operation.extent($p.fields.map((f, i) => i), $p.dataDimension);\n            $p.uniform.uFieldDomains.data = $p.fieldDomains;\n        }\n        $p.opt = operation;\n        pipeline.register('__init__');\n        return pipeline;\n    }\n\n    pipeline.view = function(views) {\n        $p.views.forEach(function(v){\n            if(v.hasOwnProperty('chart')) {\n                v.chart.svg.remove();\n                delete v.chart;\n            }\n            if(!v.hasOwnProperty('padding')) {\n                v.padding = {left: 30, right: 30, top: 30, bottom: 30};\n            }\n        })\n        $p.views = views;\n        return pipeline;\n    }\n\n    pipeline.register = function(tag) {\n        registers[tag] = {\n            indexes: $p.indexes,\n            dataSize: $p.dataSize,\n            fields: $p.fields,\n            dataDim: $p.uniform.uDataDim.data.slice(),\n            fieldWidths: $p.fieldWidths.slice(),\n            fieldDomains: $p.fieldDomains.slice(),\n            deriveCount: $p.deriveCount,\n            filterFlag: $p.uniform.uFilterFlag.data,\n            filterControls: $p.uniform.uFilterControls.data.slice(),\n            dataInput: $p.uniform.uDataInput.data,\n            attribute: {\n                aDataIdx: {\n                    ids: $p.attribute.aDataIdx.data,\n                    value: $p.attribute.aDataValx.data\n                },\n                aDataIdy: {\n                    ids: $p.attribute.aDataIdy.data,\n                    value: $p.attribute.aDataValy.data\n                },\n                aDataFieldId: $p.attribute.aDataFieldId.data,\n                aDataItemId: $p.attribute.aDataItemId.data\n            }\n        }\n        return pipeline;\n    }\n\n    pipeline.resume = function(tag) {\n        addToPipeline('resume', tag);\n        if (!registers.hasOwnProperty(tag))\n            throw new Error('\"' + tag + '\" is not found in regesters.');\n\n        var reg = registers[tag];\n        //resume CPU registers\n        $p.indexes = reg.indexes;\n        $p.dataSize = reg.dataSize;\n        $p.deriveCount = reg.deriveCount;\n        $p.fieldCount = reg.fields.length - reg.indexes.length - reg.deriveCount;\n        $p.fields = reg.fields.slice();\n        $p.fieldWidths = reg.fieldWidths.slice();\n        $p.fieldDomains = reg.fieldDomains.slice();\n        $p.dataDimension = reg.dataDim.slice();\n\n        //resume GPU Uniforms\n        $p.uniform.uFieldCount.data = $p.fieldCount;\n        $p.uniform.uDataSize.data = $p.dataSize;\n        $p.uniform.uDataDim.data = reg.dataDim;\n        $p.uniform.uIndexCount.data = reg.indexes.length;\n        $p.uniform.uFieldDomains.data = reg.fieldDomains;\n        $p.uniform.uFieldWidths.data = reg.fieldWidths;\n        $p.uniform.uFilterFlag.data = reg.filterFlag;\n        // $p.uniform.uFilterControls.data = reg.filterControls;\n        $p.uniform.uDataInput.data = reg.dataInput;\n\n        //resume GPU Attribute Buffers\n        $p.attribute['aDataIdx'] = reg.attribute['aDataIdx'].ids;\n        $p.attribute['aDataIdy'] = reg.attribute['aDataIdy'].ids;\n        $p.attribute['aDataValx'] = reg.attribute['aDataIdx'].value;\n        $p.attribute['aDataValy'] = reg.attribute['aDataIdy'].value;\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataIdx'].location, 0);\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataIdy'].location, 1);\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataValx'].location, 0);\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataValy'].location, 1);\n\n        $p.attribute['aDataFieldId'] = reg.attribute['aDataFieldId'];\n        $p.attribute['aDataItemId'] = reg.attribute['aDataItemId'];\n\n        return pipeline;\n    }\n\n    pipeline.bin = function (spec) {\n        var deriveSpec = {},\n            binAttr,\n            binCount;\n\n        if (typeof spec == 'object') {\n            binAttr = Object.keys(spec)[0];\n            binCount = spec[binAttr];\n        } else {\n            binAttr = spec;\n            //Apply Sturges' formula for determining the number of bins\n            binCount = Math.ceil(Math.log2($p.dataSize)) + 1;\n        }\n\n        var binDomain = $p.fieldDomains[$p.fields.indexOf(binAttr)];\n        var binInterval = (binDomain[1] - binDomain[0]) / binCount;\n\n        var histFunction = (function() { max(ceil((binAttr - binMin) / float(binInterval)), 1.0) })\n            .toString()\n            .slice(13, -1) // remove \"function () {\" from function.toString\n            .replace('binAttr', binAttr)\n            .replace('binMin', binDomain[0] + '.0')\n            .replace('binInterval', binInterval)\n\n        deriveSpec['bin@'+binAttr] = histFunction;\n        $p.intervals[binAttr] = {};\n        $p.intervals[binAttr].dtype = 'historgram';\n        $p.intervals[binAttr].interval = binInterval;\n        $p.intervals[binAttr].min = binDomain[0];\n        $p.intervals[binAttr].max = binDomain[1];\n        $p.intervals[binAttr].align = 'right';\n        pipeline.derive(deriveSpec);\n        // var deriveFields = $p.fields.slice(-$p.deriveCount),\n        //     dfid = deriveFields.indexOf('bin@'+binAttr);\n        // $p.deriveDomains[dfid] = [stats[binAttr].min, stats[binAttr].max];\n        return 'bin@'+binAttr;\n    }\n\n    pipeline.aggregate = function(spec) {\n        if(spec.$bin) {\n            spec.$group = pipeline.bin(spec.$bin);\n            delete spec.$bin;\n        }\n\n        addToPipeline('aggregate', spec);\n        if(Object.keys($p.crossfilters).length)\n            $p.uniform.uFilterFlag = 1;\n\n        operation.aggregate.execute(spec);\n        // console.log(JSON.stringify(pipeline.result('row')));\n        return pipeline;\n    }\n\n    pipeline.filter = function(spec) {\n        addToPipeline('filter', spec);\n        operation.match.execute(spec);\n        $p.getResult = operation.match.result;\n        return pipeline;\n    }\n\n    pipeline.match = pipeline.filter;\n\n    pipeline.derive = function(spec) {\n        addToPipeline('derive', spec);\n\n        //TODO: support JS function as expression for deriving new variable\n        //.replace(/function\\s*[\\w|\\d]+\\s*\\((.+)\\)/g, \"$1\")\n        // if (!opt.hasOwnProperty('derive')) {\n            operation.derive = optDerive($p, spec);\n        // }\n        operation.derive.execute(spec);\n        $p.getResult = operation.derive.result;\n        return pipeline;\n    }\n\n    pipeline.cache = function(tag) {\n        operation.cache.execute(tag);\n        return pipeline;\n    }\n\n    pipeline.clear = function() {\n        console.log($p.visLayers);\n    }\n\n    pipeline.read = function() {\n        console.log(\"Read>>\", $p.getResult());\n        return pipeline;\n    }\n\n    pipeline.result = output($p);\n\n    pipeline.output = function(callback) {\n        addToPipeline('output', callback);\n        callback(pipeline.result('row'));\n        return pipeline;\n    }\n\n    var branchID = 0;\n    pipeline.branch = function(branches) {\n        pipeline.register('_branch'+branchID);\n        branches.forEach(function(b){\n            var operations = Object.keys(b).map(function(o) {\n                var obj = {};\n                obj[o] = b[o];\n                return obj;\n            });\n            pipeline.run(operations);\n            pipeline.resume('_branch' + branchID);\n        })\n        branchID++;\n    }\n\n    $p.readResult = pipeline.result;\n\n    pipeline.getResult = function (d) {\n        return $p.getResult(d);\n    }\n\n    pipeline.readPixels = function(arg) {\n        var options = arg || {},\n            offset = options.offset || [0, 0],\n            resultSize = options.size || $p.dataDimension[0]* $p.dataDimension[1],\n            rowSize = Math.min(resultSize, $p.dataDimension[0]),\n            colSize = Math.ceil(resultSize/$p.dataDimension[0]);\n\n        $p.bindFramebuffer(null);\n        var gl = $p.ctx,\n            result = new Uint8Array(rowSize * colSize * 4);\n\n        gl.readPixels(offset[0], offset[1], rowSize, colSize, gl.RGBA, gl.UNSIGNED_BYTE, result);\n        return result.filter(function(d, i){ return i%4===3;} );\n    }\n\n    pipeline.clearViews = function() {\n        $p.bindFramebuffer(\"offScreenFBO\");\n        $p.ctx.clearColor( 0.0, 0.0, 0.0, 0.0 );\n        $p.ctx.clear( $p.ctx.COLOR_BUFFER_BIT | $p.ctx.DEPTH_BUFFER_BIT );\n        $p.bindFramebuffer(\"visStats\");\n        $p.ctx.clearColor( 0.0, 0.0, 0.0, 0.0 );\n        $p.ctx.clear( $p.ctx.COLOR_BUFFER_BIT | $p.ctx.DEPTH_BUFFER_BIT );\n        $p.bindFramebuffer(null);\n        $p.ctx.clearColor( 0.0, 0.0, 0.0, 0.0 );\n        $p.ctx.clear( $p.ctx.COLOR_BUFFER_BIT | $p.ctx.DEPTH_BUFFER_BIT );\n    }\n\n    pipeline.runSpec = function(specs) {\n        pipeline.head();\n        pipeline.clearViews();\n        $p.interactions = [];\n        response = {};\n        $p.pipeline = [];\n        $p.crossfilters = [];\n        $p.uniform.uFilterFlag.data = 0;\n        // $p.uniform.uFilterRanges = $p.fieldDomains.concat($p.deriveDomains);\n        specs.forEach(function(spec){\n            var opt = Object.keys(spec)[0],\n                arg = spec[opt];\n\n            opt = opt.slice(1);\n            if(typeof pipeline[opt] == 'function') {\n                pipeline[opt](arg);\n            }\n        })\n    }\n\n    pipeline.head = function() {\n        pipeline.resume('__init__');\n        return pipeline;\n    }\n\n    pipeline.run = function(opts) {\n        var operations = opts || $p.pipeline;\n        operations.forEach(function(p, i){\n            var opt = Object.keys(p)[0];\n            pipeline[opt](p[opt]);\n        })\n\n        return pipeline;\n    }\n\n    pipeline.visualize = function(vmap) {\n        var optID = addToPipeline('visualize', vmap);\n        var viewIndex = 0,\n            filters = {};\n        if(typeof vmap.id == 'string') {\n            viewIndex = $p.views.map(d=>d.id).indexOf(vmap.id);\n            if(viewIndex == -1) {\n                //find the next available view slot in all views\n                for(var vi = 0; vi < $p.views.length; vi++){\n                    if(!$p.views[vi].id) {\n                        viewIndex = vi;\n                        $p.views[viewIndex].id = vmap.id;\n                        break;\n                    }\n                }\n            }\n        }\n        if(vmap.mark == 'bar') vmap.zero = true;\n        $p.views[viewIndex].vmap = vmap;\n        var encoding = vmap,\n            viewTag = $p.views[viewIndex].id;\n\n        if($p._update && response.hasOwnProperty(viewTag)) {\n            if(response[viewTag].hasOwnProperty($p._responseType)) {\n                encoding = Object.assign({}, vmap, response[viewTag][$p._responseType]);\n            }\n        }\n        if(encoding.opacity != 0){\n            operation.visualize({\n                vmap: encoding,\n                viewIndex: viewIndex\n            });\n            pipeline.interact();\n\n        }\n        return pipeline;\n    }\n\n    pipeline.interact = function(spec) {\n        if(typeof(spec) != 'undefined') $p.interactions.push(spec);\n        $p.interactions.forEach(function(interaction){\n            interact($p, {\n                actions: interaction.event,\n                view: interaction.from,\n                condition: interaction.condition,\n                callback: function(selection) {\n                    response = interaction.response;\n                    if(!$p._update) {\n                        $p._update = true;\n                        $p.crossfilters = {};\n                        if(typeof selection == 'object') {\n                            Object.keys(selection).forEach(function(k) {\n                                if(selection[k].length < 2) {\n                                    if($p.intervals.hasOwnProperty(k)) {\n                                        var value = (Array.isArray(selection[k]))\n                                            ? selection[k][0]\n                                            : selection[k];\n                                        selection[k] = [value-$p.intervals[k].interval, value];\n                                    } else if(!$p.categoryLookup.hasOwnProperty(k)) {\n                                        selection[k] = [selection[k][0] + selection[k][0] + 1];\n                                    }\n                                }\n                                $p.crossfilters[k] = selection[k];\n                            });\n                        }\n                        $p._responseType = 'unselected';\n                        $p.uniform.uFilterLevel.data = 0.2;\n                        $p.uniform.uVisLevel.data = 0.1;\n                        pipeline.head().run();\n                        $p._responseType = 'selected';\n                        $p.uniform.uVisLevel.data = 0.2;\n                        pipeline.head().filter({}).run();\n                        $p._responseType = 'unselected';\n                        $p._update = false;\n                        $p.uniform.uFilterLevel.data = 0.1;\n                        $p.uniform.uVisLevel.data = 0.1;\n                    }\n                }\n            })\n        })\n    }\n\n    pipeline.exportImage = function(beforeExport) {\n        var beforeExport = beforeExport || function() { pipeline.head().run() };\n        if(typeof operation.visualize.chart.exportImage === 'function') {\n            return operation.visualize.chart.exportImage(beforeExport);\n        } else {\n            return pipeline;\n        }\n    }\n\n    if(options.hasOwnProperty('data')) {\n        pipeline.data(options.data);\n    }\n\n    return pipeline;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/pipeline.js\n// module id = 15\n// module chunks = 0","import {seqFloat} from './utils';\nconst vecId = ['x', 'y', 'z'];\nexport default function($p, dataProps) {\n    var data = dataProps || [];\n\n    $p.indexes = data.indexes || [];\n    $p.categoryIndex = data.strHashes || {};\n    $p.categoryLookup = data.strLists || {};\n    $p.dkeys =  data.keys || [];\n    $p.dtypes =  data.dtypes || data.types || [];\n    $p.intervals =  data.intervals || {};\n    $p.cachedResult = [];\n    $p.pipeline = [];\n    $p.crossfilters = {};\n    $p.deriveCount = 0;\n    $p.resultDimension = [1, 1];\n    $p.dataSize = 0;\n\n    var dkeys = $p.dkeys,\n        dtypes = $p.dtypes,\n        stats =  data.stats || null;\n\n    if (data.hasOwnProperty(\"size\"))\n        $p.dataSize = data.size;\n    else if (Array.isArray(data))\n        $p.dataSize = Math.max.apply(null, data.map(function(d) {\n            return d.length;\n        }));\n\n    var rowSize = Math.min($p.dataSize, 8192),\n        colSize = Math.ceil($p.dataSize / rowSize);\n\n    $p.dataDimension = [rowSize, colSize];\n\n    $p.fields = $p.indexes.concat(dkeys.filter(function(k) {\n        return $p.indexes.indexOf(k) === -1;\n    }));\n    $p.fieldWidths = new Array($p.fields.length).concat(new Array($p.deriveMax).fill(1));\n    $p.fieldCount = $p.fields.length - $p.indexes.length;\n\n\n    function getDataWidth(fid, range) {\n        var range = Math.abs(range[1] - range[0]);\n        if (dtypes[fid] == \"index\" || dtypes[fid] == \"int\" || dtypes[fid] == \"string\") {\n            return range + 1;\n        } else if (dtypes[fid] == \"histogram\") {\n            return range;\n        } else if (dtypes[fid] == \"time\") {\n            var interval = stats[$p.fields[fid]].min;\n            if (interval === 0) interval = (data[fid][1] - data[fid][0]) || 1;\n            $p.intervals[dkeys[fid]] = {};\n            $p.intervals[dkeys[fid]].dtype = 'time';\n            $p.intervals[dkeys[fid]].interval = interval;\n            $p.intervals[dkeys[fid]].min = stats[dkeys[fid]].min;\n            $p.intervals[dkeys[fid]].max = stats[dkeys[fid]].max;\n            return range / interval + 1;\n        } else if ([\"nominal\", \"ordinal\", \"categorical\"].indexOf(dtypes[fid]) > -1) {\n            return data.TLB.length;\n        } else if (dtypes[fid] in [\"float\", \"double\", \"numeric\"]) {\n            return 10;\n        } else {\n            return range+1;\n        }\n    }\n    $p.fields.forEach(function(field) {\n        var min = stats[field].min,\n            max = stats[field].max,\n            fi = dkeys.indexOf(field);\n        $p.fieldWidths[fi] = getDataWidth(fi, [min, max]);\n    });\n    $p.getDataWidth = getDataWidth;\n    $p.deriveDomains = new Array($p.deriveMax).fill([0, 1]);\n    $p.deriveWidths = new Array($p.deriveMax).fill(1);\n    $p.deriveFieldCount = 0;\n\n    if ($p.indexes.length === 0) {\n        $p.attribute(\"aDataIdx\", \"float\", seqFloat(0, $p.dataDimension[0] - 1));\n        $p.attribute(\"aDataIdy\", \"float\", seqFloat(0, $p.dataDimension[1] - 1));\n        $p.attribute(\"aDataValx\", \"float\", seqFloat(0, $p.dataDimension[0] - 1));\n        $p.attribute(\"aDataValy\", \"float\", seqFloat(0, $p.dataDimension[1] - 1));\n    } else {\n\n        $p.indexes.forEach(function(id, i) {\n            var indexAttrData = arrays.unique(data[id]).sort(function(a, b) {\n                return a - b;\n            });\n            $p.attribute(\"aDataVal\" + vecId[i], \"float\", new Float32Array(indexAttrData));\n            $p.attribute(\"aDataId\" + vecId[i], \"float\", seqFloat(0, indexAttrData.length - 1));\n            $p.fieldWidths[i] = indexAttrData.length;\n            $p.dataDimension[i] = indexAttrData.length;\n        });\n    }\n\n    $p.attribute(\"aDataItemVal0\", \"float\", null);\n    $p.attribute(\"aDataItemVal1\", \"float\", null);\n    $p.attribute(\"aDataItemId\", \"float\", new Float32Array($p.dataSize).map((d,i)=>i));\n    $p.attribute(\"aDataFieldId\", \"vec2\", new Float32Array($p.fields.length * 2).map((d,i)=>i));\n    $p.attribute(\"aVertexId\", \"float\", [0, 1, 2, 3, 4, 5]);\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aVertexId.location, 0);\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataFieldId.location, 0);\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataItemId.location, 1);\n\n    $p.attribute(\"_square\", \"vec2\", new Float32Array([-1.0, -1.0,\n        1.0, -1.0, -1.0, 1.0, -1.0, 1.0,\n        1.0, -1.0,\n        1.0, 1.0\n    ]));\n    $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute._square.location, 1);\n\n    //setup all attribute, uniform, texture, varying needed by all the shaders\n    $p.uniform(\"uDataSize\",    \"float\", $p.dataSize);\n    $p.uniform(\"uDataDim\",     \"vec2\",  $p.dataDimension);\n    $p.uniform(\"uResultDim\",   \"vec2\",  $p.dataDimension);\n    $p.uniform(\"uIndexCount\",  \"int\",   $p.indexes.length);\n    $p.uniform(\"uFieldWidths\", \"float\", $p.fieldWidths);\n    $p.uniform(\"uFieldCount\",  \"int\",   $p.fieldCount);\n    $p.uniform(\"uFieldId\",     \"int\",   0);\n    $p.uniform(\"uFilterFlag\",  \"int\",   0);\n    $p.uniform(\"uGroupFields\", \"int\",   [0, -1]);\n    $p.uniform(\"uDataInput\",   \"sampler2D\");\n    $p.uniform(\"uDeriveCount\", \"int\", $p.deriveMax);\n    // $p.uniform(\"uDeriveDomains\", \"vec2\", $p.deriveDomains);\n    // $p.uniform(\"uDeriveWidths\", \"float\", $p.deriveWidths);\n\n    $p.uniform(\"uFilterLevel\", \"float\", 0.1)\n    $p.uniform('uVisLevel',    \"float\", 0.1)\n\n    $p.varying(\"vResult\", \"float\");\n    $p.varying(\"vDiscardData\", \"float\");\n    $p.texture(\n        \"tData\",\n        \"float\",\n        new Float32Array($p.dataDimension[0] * $p.dataDimension[1] * $p.fieldCount), [$p.dataDimension[0], $p.dataDimension[1] * $p.fieldCount],\n        \"alpha\"\n    );\n    $p.framebuffer(\"fFilterResults\", \"unsigned_byte\", $p.dataDimension);\n    $p.framebuffer(\"fGroupResults\", \"float\", [1024, 1]);\n    $p.framebuffer(\"fDerivedValues\", \"float\", [$p.dataDimension[0], $p.dataDimension[1] * $p.deriveMax]);\n\n    $p.parameter({\n        fieldCount: $p.fields.length - $p.indexes.length,\n        indexCount: $p.indexes.length\n    });\n\n    $p.fields.slice($p.indexes.length).forEach(function(attr, ai) {\n        var buf = new Float32Array($p.dataDimension[0] * $p.dataDimension[1]);\n        for (var i = 0, l = data[attr].length; i < l; i++) {\n            buf[i] = data[attr][i];\n        }\n        $p.texture.tData.update(\n            buf, [0, $p.dataDimension[1] * ai], $p.dataDimension\n        );\n    });\n\n    //TODO: get data statistics using the GPU\n    if(stats !== null) {\n        $p.fieldDomains = $p.fields.map(function(k, i) {\n            return [stats[k].min, stats[k].max];\n        })\n        .concat(new Array($p.deriveMax).fill([0, 1]));\n\n        $p.uniform(\"uFieldDomains\", \"vec2\",  $p.fieldDomains);\n\n    } else {\n        $p.uniform(\"uFieldDomains\", \"vec2\",  $p.fields.map(f => [0, 1]));\n    }\n\n\n    // $p.texture.tData.sampler = $p.uniform.uDataInput;\n    $p.uniform.uDataInput = $p.texture.tData;\n\n    function getFieldWidth($int_fid) {\n        return this.uFieldWidths[fid];\n    }\n\n    function getFieldDomain($int_fid) {\n        return this.uFieldDomains[fid];\n    }\n\n    function getData($int_fid, $float_r, $float_s) {\n        var t, value;\n        if (fid >= this.uFieldCount + this.uIndexCount) {\n            t = (float(fid - this.uFieldCount - this.uIndexCount) + s) /\n                float(this.uDeriveCount);\n            value = texture2D(this.fDerivedValues, vec2(r, t)).a;\n        } else {\n            if (this.uIndexCount > 0 && fid == 0) value = this.aDataValx;\n            else if (this.uIndexCount > 1 && fid == 1) value = this.aDataValy;\n            else {\n                t = (float(fid - this.uIndexCount) + s) / float(this.uFieldCount);\n                value = texture2D(this.uDataInput, vec2(r, t)).a;\n            }\n        }\n        return value;\n    }\n\n    function getNonIndexedData($int_fieldId, $float_addrX, $float_addrY) {\n        var offsetY, value;\n        if (fieldId >= this.uFieldCount + this.uIndexCount) {\n            offsetY = (float(fieldId - this.uFieldCount - this.uIndexCount) + addrY) /\n                float(this.uDeriveCount);\n            value = texture2D(this.fDerivedValues, vec2(addrX, offsetY)).a;\n        } else {\n            offsetY = (float(fieldId - this.uIndexCount) + addrY) / float(this.uFieldCount);\n            value = texture2D(this.uDataInput, vec2(addrX, offsetY)).a;\n        }\n        return value;\n    }\n\n    $p.subroutine(\"getFieldWidth\", \"float\", getFieldWidth);\n    $p.subroutine(\"getFieldDomain\", \"vec2\", getFieldDomain);\n    $p.subroutine(\"getData\", \"float\", getData);\n    $p.subroutine(\"getNonIndexedData\", \"float\", getNonIndexedData);\n\n    var gl = $p.ctx;\n    gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n    gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n    gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n    gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/allocate.js\n// module id = 16\n// module chunks = 0","export default function output($p) {\n    return function(format) {\n        var buf = $p.getResult(),\n            res = {},\n            offset = 0;\n\n        var rs = 0;\n\n        if ($p.resultDimension[0] > 1) {\n            res[$p.fields[rs]] = $p.attribute.aDataValx.data;\n            rs++;\n        }\n\n        if ($p.resultDimension[1] > 1) {\n            var bx = $p.attribute.aDataValx.data;\n            var by = $p.attribute.aDataValy.data;\n            var ax = new Array($p.resultDimension[0] * $p.resultDimension[1]),\n                ay = new Array($p.resultDimension[0] * $p.resultDimension[1]);\n\n            for (var y = 0; y < $p.resultDimension[1]; y++) {\n                for (var x = 0; x < $p.resultDimension[0]; x++) {\n\n                    ax[y * $p.resultDimension[0] + x] = bx[x];\n                    ay[y * $p.resultDimension[0] + x] = by[y]\n                }\n            }\n            res[$p.fields[0]] = ax;\n            res[$p.fields[rs]] = ay;\n            rs++;\n        }\n\n        var arraySize = $p.resultDimension[0] * $p.resultDimension[1];\n\n        for (var i = rs; i < $p.fields.length; i++) {\n            res[$p.fields[i]] = buf.subarray(offset, offset + arraySize);\n            offset += arraySize;\n        };\n\n        if (format == 'row') {\n            var objectArray = new Array(arraySize);\n\n            for (var i = 0; i < arraySize; i++) {\n                var obj = {};\n                Object.keys(res).forEach(function(f) {\n                    var kid = $p.dkeys.indexOf(f),\n                        dtype = $p.dtypes[kid];\n\n                    if (dtype == 'string' && $p.categoryLookup.hasOwnProperty(f)) {\n                        obj[f] = $p.categoryLookup[f][res[f][i]];\n                    } else if ($p.intervals.hasOwnProperty(f) && $p.intervals[f].dtype == 'historgram') {\n                        obj[f] = $p.intervals[f].min + res[f][i] * $p.intervals[f].interval;\n                    } else {\n                        obj[f] = res[f][i];\n                    }\n                });\n                objectArray[i] = obj;\n            }\n\n            return objectArray;\n\n        } else {\n            return res;\n        }\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/output.js\n// module id = 17\n// module chunks = 0","import FlexGL from '../flexgl/src/flexgl';\n\nexport default function init(options) {\n    var $p = options.context || null,\n        container = options.container || document.body,\n        viewport = options.viewport || [800, 450],\n        padding = {left:0, right: 0,top: 0, bottom: 0};\n\n    var defaultLayout = [\n        {\n            width: viewport[0],\n            height: viewport[1],\n            padding: {left: 30, right: 30, top: 30, bottom: 30},\n            offset: [0, 0]\n        }\n    ];\n    if ($p === null) {\n        $p = new FlexGL({\n            container: container,\n            width: viewport[0],\n            height: viewport[1],\n            padding: padding\n        });\n        $p.padding = padding;\n        $p.viewport = viewport;\n    }\n    $p.container = container;\n    $p.views = options.views || defaultLayout;\n    return $p;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/initialize.js\n// module id = 18\n// module chunks = 0","import Resource from './resource';\nimport ProgramManager from './program';\nimport Shader from './shader';\nimport Framebuffer from './framebuffer';\n\nexport default function FlexGL(arg) {\n\n    var flexgl = (this instanceof FlexGL) ? this : {},\n        options = arg || {},\n        container = options.container || null,\n        canvas = options.canvas || document.createElement(\"canvas\"),\n        width = options.width || null,\n        height = options.height || null,\n        padding = options.padding || {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        },\n        ctx = options.context || options.ctx || null,\n        kernels = {},\n        program = null,\n        sharedFunction = options.sharedFunction || {};\n\n\n    if (typeof(canvas) == \"string\") {\n        if (canvas[0] == \"#\") canvas = document.getElementById(cavnas.substring(1));\n        else canvas = document.getElementById(cavnas);\n    }\n    if (container) {\n        container = (typeof(container) == \"string\") ? document.getElementById(container) : container;\n        if (width === null) width = container.clientWidth;\n        if (height === null) height = container.clientHeight;\n    }\n    // width -= padding.left + padding.right;\n    // height -= padding.top + padding.bottom;\n    canvas.width = width;\n    canvas.height = height;\n    canvas.style.position = \"absolute\";\n    canvas.style.marginLeft = padding.left + \"px\";\n    canvas.style.marginTop = padding.top + \"px\";\n\n    if (ctx === null)\n        ctx = setupWebGL(canvas);\n    flexgl.ctx = ctx;\n    flexgl.canvas = canvas;\n\n    ctx._dict = options.env || options.dict || options.dictionary || {};\n\n\n    var resources = new Resource(ctx),\n        framebuffers = new Framebuffer(ctx),\n        programManager = new ProgramManager(ctx, resources),\n        shaders = new Shader(ctx, resources);\n\n    var blendExt = ctx.getExtension(\"EXT_blend_minmax\");\n    if (blendExt) {\n        ctx.MAX_EXT = blendExt.MAX_EXT;\n        ctx.MIN_EXT = blendExt.MIN_EXT;\n    }\n\n    ctx.ext = ctx.getExtension(\"ANGLE_instanced_arrays\");\n    enableExtension([\n        \"OES_texture_float\",\n        \"OES_texture_float_linear\",\n        // \"OES_texture_half_float\",\n        // \"OES_texture_half_float_linear\"\n    ]);\n\n    if (container)\n        container.appendChild(canvas);\n\n    function setupWebGL(canvas) {\n        var names = [\"webgl\", \"experimental-webgl\"];\n        var gl = null;\n        for (var i = 0; i < names.length; ++i) {\n            try {\n                gl = canvas.getContext(names[i]);\n            } catch (e) {}\n            if (gl) break;\n        }\n        return gl;\n    }\n\n    function enableExtension(extensions) {\n        if (!Array.isArray(extensions)) extensions = [extensions];\n        extensions.forEach(function(extension) {\n            var extProps = ctx.getExtension(extension);\n            if (extProps !== null) {\n                Object.keys(extProps).forEach(function(ep) {\n                    if (!ext.hasOwnProperty(ep)) {\n                        ctx.ext[ep] = extProps[ep];\n                    }\n                })\n            }\n        });\n    };\n\n    flexgl.enableExtension = enableExtension;\n\n    /**\n     * Allocate Attributes in vertex buffer array stored in GPU memory\n     * @param  {String} name attribute name\n     * @param  {String} type attribute type: float, vec2, ...\n     * @param  {Array} data data values\n     * @return {Object}      FLexGL object\n     */\n    flexgl.attribute = function(name, type, data) {\n        resources.allocate(\"attribute\", name, type, data);\n        Object.defineProperty(flexgl.attribute, name, {\n            get: function() {\n                return resources.attribute[name];\n            },\n            set: function(data) {\n                resources.attribute[name].load(data);\n            }\n        });\n        return flexgl;\n    };\n    flexgl.buffer = flexgl.attribute; //alias\n\n    /**\n     * Create a Uniform variable for WebGL shader programs\n     * @param  {String} name attribute name\n     * @param  {String} type uniform variable type: float, vec2, ...\n     * @param  {Array} data data values\n     * @return {Object}      FLexGL object\n     */\n    flexgl.uniform = function(name, type, data) {\n        resources.allocate(\"uniform\", name, type, data);\n        if (!flexgl.uniform.hasOwnProperty(name)) {\n            Object.defineProperty(flexgl.uniform, name, {\n                get: function() {\n                    return resources.uniform[name];\n                },\n                set: function(data) {\n                    resources.uniform[name].load(data);\n                    if (ctx.isProgram(program))\n                        resources.uniform[name].link(program);\n                }\n            });\n        }\n        return flexgl;\n    };\n\n    flexgl.uniform.serialize = function(aoa) {\n        var sa = [];\n        aoa.forEach(function(a) {\n            sa = sa.concat(a);\n        })\n        return sa;\n    }\n\n    /**\n     * Create a Uniform variable for WebGL shader programs\n     * @param  {String} name attribute name\n     * @param  {String} type texture type: unsigned_byte or float, ...\n     * @param  {Array} data data values\n     * @param  {Array} dim [width, height]\n     * @param  {String} [channel='alpha'] WebGL formats (rgba, alpha)\n     * @param  {Object} [sampler=null] FLexGL Uniform Object\n     * @return {Object}      FLexGL object\n     */\n    flexgl.texture = function(name, type, data, dim, channel, sampler) {\n        resources.allocate(\"texture\", name, type, dim, channel, data, sampler);\n        Object.defineProperty(flexgl.texture, name, {\n            get: function() {\n                return resources.texture[name];\n            },\n            set: function(data) {\n                resources.texture[name].load(data);\n            }\n        });\n        return flexgl;\n    }\n\n    flexgl.texture.update = function(name, data, offset, dim) {\n        resources.texture[name].update(data, offset, dim);\n    }\n\n    /**\n     * Create a Uniform variable for WebGL shader programs\n     * @param  {String} name attribute name\n     * @param  {String} [type] Varying variable type: float, vec2, ...\n     * @param  {Number} [size=1] data array\n     * @return {Object}      FLexGL object\n     */\n    flexgl.varying = function(name, type, size) {\n        resources.allocate(\"varying\", name, type, size);\n        return flexgl;\n    };\n\n    /**\n     * Create a Uniform variable for WebGL shader programs\n     * @param  {String} name attribute name\n     * @param  {String} type attribute type: float, vec2, ...\n     * @param  {Array} dim [width, height]\n     * @param  {Object} [texture=null] FLexGL Texture Object\n     * @return {Object}      FLexGL object\n     */\n    flexgl.framebuffer = function(name, type, dim, texture) {\n        var texture = texture || resources.allocate('texture', name, type, dim, 'rgba', null);\n\n        framebuffers.create(name, type, dim, texture);\n        if (!flexgl.framebuffer.hasOwnProperty(name)) {\n            Object.defineProperty(flexgl.framebuffer, name, {\n                get: function() {\n                    return framebuffers[name];\n                }\n            });\n        }\n        return flexgl;\n    }\n\n    flexgl.framebuffer.enableRead = function(name) {\n        framebuffers[name].enableRead(program);\n    }\n\n    flexgl.bindFramebuffer = function(fbName) {\n        if (fbName === null)\n            ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);\n        else\n            ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebuffers[fbName].ptr);\n    }\n\n    flexgl.subroutine = function(name, type, fn) {\n        resources.allocate(\"subroutine\", name, type, fn);\n        return flexgl;\n    }\n\n    flexgl.parameter = function(keyValuePairs) {\n        Object.keys(keyValuePairs).forEach(function(key) {\n            ctx._dict[key] = keyValuePairs[key];\n            if (Array.isArray(ctx._dict[key])) {\n                var i = 0;\n                Object.defineProperty(ctx._dict, key, {\n                    get: function() {\n                        return keyValuePairs[key][i++];\n                    },\n                    set: function(newArray) {\n                        i = 0;\n                        ctx._dict[key] = newArray;\n                    }\n                });\n            } else if(typeof(ctx._dict[key]) == 'object') {\n                var dictKeys = Object.keys(ctx._dict[key]);\n                fxgl.uniform('dict'+key, 'float', dictKeys.map(d=>ctx._dict[key][d]));\n            }\n        })\n        return flexgl;\n    }\n\n    flexgl.dictionary = flexgl.parameter;\n\n    flexgl.shader = programManager.shader;\n\n    flexgl.program = function(name, vs, fs) {\n        program = programManager.program(name, vs, fs);\n        return ctx;\n    }\n\n    flexgl.createProgram = function(name, vs, fs) {\n        program = programManager.create(name, vs, fs);\n        return ctx;\n    }\n\n    flexgl.app = function(name, props) {\n        var vs = flexgl.shader.vertex(props.vs),\n            fs = flexgl.shader.fragment(props.fs),\n            fb = props.framebuffer || null;\n\n        flexgl.program(name, vs, fs);\n\n        var draw = props.render || props.draw;\n\n        return function(args) {\n            var gl = flexgl.program(name);\n            return draw.call(gl, args);\n        }\n    }\n\n    flexgl.dimension = function() {\n        return [canvas.width, canvas.height];\n    }\n\n    flexgl.resources = resources;\n\n    return flexgl;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flexgl/src/flexgl.js\n// module id = 19\n// module chunks = 0","import Uniform from './uniform';\nimport Attribute from './attribute';\nimport Texture from './texture';\nimport Varying from './varying';\nimport Subroutine from './subroutine';\n\nexport default function Resource(glContext) {\n    var resource = (this instanceof Resource) ? this : {},\n        gpuResources = {};\n\n    resource.uniform = new Uniform(glContext);\n    resource.attribute = new Attribute(glContext);\n    resource.texture = new Texture(glContext);\n    resource.varying = new Varying(glContext);\n    resource.subroutine = new Subroutine();\n\n    var resourceTypes = ['uniform', 'attribute', 'texture', 'varying', 'subroutine'];\n\n    resource.allocate = function(type, props) {\n        if (resourceTypes.indexOf(type) === -1) {\n            throw Error(\"Error: Invalid resource type: \" + type);\n        }\n        var res = resource[type].create.apply(null, Array.prototype.slice.call(arguments, 1));\n        res.resourceType = type;\n        gpuResources[res.name] = res;\n        if (!gpuResources.hasOwnProperty(res.name)) {\n            Object.defineProperty(gpuResources, res.name, {\n                get: function() {\n                    return gpuResources[res.name];\n                },\n                set: function(data) {\n                    gpuResources[res.name].load(data);\n                }\n            });\n        }\n        return res;\n    };\n\n    resource.link = function(program, resources) {\n        var requiredResources = (Array.isArray(resources)) ? resources : Object.keys(gpuResources);\n        requiredResources.forEach(function(resourceName) {\n            if (gpuResources.hasOwnProperty(resourceName))\n                gpuResources[resourceName].link(program);\n        })\n    };\n\n    resource.get = function(name) {\n        return gpuResources[name];\n    }\n\n    resource.create = resource.allocate;\n\n    return resource;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flexgl/src/resource.js\n// module id = 20\n// module chunks = 0","export default function Attribute(glContext) {\n    \n    var attribute = (this instanceof Attribute) ? this : {},\n        ctx = glContext,\n        attributeID = 0;\n\n    function setAttribute(name, data) {\n        if(Array.isArray(data) || ArrayBuffer.isView(data)){\n            if(!ArrayBuffer.isView(data)) data = new Float32Array(data);\n            attribute[name].data = data;\n            ctx.bindBuffer(ctx.ARRAY_BUFFER, attribute[name].ptr);\n            ctx.bufferData(ctx.ARRAY_BUFFER, data, ctx.STATIC_DRAW);\n        }\n    }\n    attribute.create = function(name, type, data) {\n        attribute[name] = {\n            name: name,\n            type: type || 'float',\n            data: null,\n            location: attributeID++,\n            ptr: ctx.createBuffer(),\n            size: parseInt(type.slice(3,4)) || 1\n        };\n\n        if(data !== null && data.length) setAttribute(name, data);\n\n        attribute[name].link = function(program) {\n            ctx.bindBuffer(ctx.ARRAY_BUFFER, this.ptr);\n            this.location = ctx.getAttribLocation(program, this.name);\n            ctx.vertexAttribPointer(this.location, this.size, ctx.FLOAT, false, 0, 0);\n            ctx.enableVertexAttribArray(this.location);\n            return this;\n        }\n\n        attribute[name].load = function(arrayBuffer) {\n            setAttribute(this.name, arrayBuffer);\n            return this;\n        }\n\n        attribute[name].header = function() {\n            return 'attribute ' + this.type + ' ' + this.name + ';\\n';\n        }\n\n        attribute[name].delete = function() {\n            ctx.deleteBuffer(this.ptr);\n        }\n\n        return attribute[name];\n    };\n\n    return attribute;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flexgl/src/attribute.js\n// module id = 21\n// module chunks = 0","export default function Varying(glContext) {\n\n    var varying = (this instanceof Varying) ? this : {},\n        ctx = glContext;\n\n    varying.create = function(name, type, size) {\n        varying[name] = {\n            name: name,\n            type: type || 'float',\n            size: size || 1,\n        };\n\n        varying[name].link = function() {};\n\n        varying[name].header = function() {\n            var header = 'varying ' + this.type + ' ' + this.name;\n            if(this.size > 1)\n                header += '[' + this.size + ']';\n            return header + ';\\n';\n        }\n\n        return varying[name];\n    }\n\n    return varying;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flexgl/src/varying.js\n// module id = 22\n// module chunks = 0","export default function Subroutine() {\n\n    var subroutine = (this instanceof Subroutine) ? this : {};\n\n    subroutine.create = function(name, type, fn) {\n        subroutine[name] = {\n            name: name,\n            type: type || 'float',\n            fn: fn,\n            resourceType: \"subroutine\"\n        };\n\n        subroutine[name].link = function(program) {\n            return this;\n        }\n\n        subroutine[name].load = function(fn) {\n            subroutine[name].fn = fn;\n            return this;\n        }\n\n        subroutine[name].header = function() {\n            return this.fn.toString();\n        }\n\n        return subroutine[name];\n    };\n\n    return subroutine;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flexgl/src/subroutine.js\n// module id = 23\n// module chunks = 0","import Shader from './shader';\n\nexport default function Program(glContext, resources) {\n\n    var program,\n        ctx = glContext,\n        pm = {},\n        kernels = {},\n        shaders = new Shader(glContext, resources);\n\n    pm.create = function(name, vs, fs) {\n        var name = name || \"default\",\n            vs = vs || \"default\",\n            fs = fs || \"default\",\n            deps = [];\n\n        if (kernels.hasOwnProperty(name)) {\n            pm.delete(name);\n        }\n\n        kernels[name] = ctx.createProgram();\n\n        kernels[name].vs = (typeof vs == \"object\") ? vs : shaders.vertex[vs];\n        kernels[name].fs = (typeof fs == \"object\") ? fs : shaders.fragment[fs];\n\n        ctx.attachShader(kernels[name], kernels[name].vs);\n        ctx.attachShader(kernels[name], kernels[name].fs);\n        ctx.linkProgram(kernels[name]);\n        var linked = ctx.getProgramParameter(kernels[name], ctx.LINK_STATUS);\n        if (!linked) {\n            var lastError = ctx.getProgramInfoLog(kernels[name]);\n            throw (\"Error in program linking:\" + lastError);\n            ctx.deleteProgram(kernels[name]);\n            return null;\n        }\n\n        deps = deps.concat(kernels[name].vs.deps);\n        deps = deps.concat(kernels[name].fs.deps);\n        kernels[name].deps = deps;\n\n        return kernels[name];\n    }\n\n    pm.use = pm.program = function(name, vs, fs) {\n        if (kernels.hasOwnProperty(name)) {\n            program = kernels[name];\n            ctx.useProgram(program);\n            resources.link(program, program.deps);\n            return program;\n        } else {\n            return pm.create(name, vs, fs);\n        }\n    }\n\n    pm.delete = function(name) {\n        if (kernels.hasOwnProperty(name)) {\n            ctx.detachShader(kernels[name], kernels[name].vs);\n            ctx.detachShader(kernels[name], kernels[name].fs);\n            ctx.deleteProgram(kernels[name]);\n            delete kernels[name];\n        }\n    }\n\n    pm.shader = function(arg, fn) {\n        var options = arg;\n        shaders.create(options, fn);\n        return pm;\n    }\n\n    pm.shader.vertex = function(fn) {\n        var options = {\n            type: \"vertex\"\n        };\n        if (fn.name) options.name = fn.name;\n        return shaders.create(options, fn);\n    }\n\n    pm.shader.fragment = function(fn) {\n        var options = {\n            type: \"fragment\"\n        };\n        if (fn.name) options.name = fn.name;\n        return shaders.create(options, fn);\n    }\n\n    return pm;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flexgl/src/program.js\n// module id = 24\n// module chunks = 0","import Texture from './texture';\n\nexport default function Framebuffer(glContext) {\n\n    var framebuffer = (this instanceof Framebuffer) ? this : {},\n        ctx = glContext;\n\n    framebuffer.create = function(name, type, dim, texture) {\n\n        framebuffer[name] = {\n            ptr: ctx.createFramebuffer(),\n            name: name,\n            type: type || \"float\",\n            width: dim[0] || 1024,\n            height: dim[1] || 1024,\n            texture: texture || null,\n            renderbuffer: ctx.createRenderbuffer(),\n        }\n\n        if (framebuffer[name].texture === null) {\n            var buf = (type == 'float') ?\n                new Float32Array(dim[0] * dim[1] * 4) :\n                new Uint8Array(dim[0] * dim[1] * 4);\n            framebuffer[name].texture = Texture(ctx).create(name, type, dim, \"rgba\", buf);\n        }\n\n        var renderbuffer = framebuffer[name].renderbuffer;\n        ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebuffer[name].ptr);\n        ctx.bindRenderbuffer(ctx.RENDERBUFFER, renderbuffer);\n        ctx.renderbufferStorage(\n            ctx.RENDERBUFFER,\n            ctx.DEPTH_COMPONENT16,\n            framebuffer[name].width,\n            framebuffer[name].height\n        );\n        ctx.framebufferTexture2D(\n            ctx.FRAMEBUFFER,\n            ctx.COLOR_ATTACHMENT0,\n            ctx.TEXTURE_2D,\n            framebuffer[name].texture.ptr,\n            0\n        );\n        ctx.framebufferRenderbuffer(\n            ctx.FRAMEBUFFER,\n            ctx.DEPTH_ATTACHMENT,\n            ctx.RENDERBUFFER,\n            renderbuffer\n        );\n        ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);\n        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);\n\n        framebuffer[name].enableRead = function(program) {\n            ctx.activeTexture(ctx.TEXTURE0 + this.texture.index);\n            ctx.bindTexture(ctx.TEXTURE_2D, this.texture.ptr);\n            this.texture.location = ctx.getUniformLocation(program, this.texture.name);\n            ctx.uniform1i(this.texture.location, this.texture.index);\n        };\n\n        framebuffer[name].delete = function() {\n            ctx.bindRenderbuffer(gl.RENDERBUFFER, null);\n            ctx.bindFramebuffer(gl.FRAMEBUFFER, null);\n            ctx.deleteRenderbuffer(this.renderbuffer);\n            ctx.deleteTexture(this.texture.ptr)\n            ctx.deleteFramebuffer(this.ptr);\n        };\n\n        return framebuffer[name];\n    }\n\n    return framebuffer;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flexgl/src/framebuffer.js\n// module id = 25\n// module chunks = 0","import derive from './derive';\nimport reveal from './reveal';\nimport aggregate from './aggregate';\nimport cache  from './cache';\nimport match from './match';\nimport extent from './extent';\nimport visualize from './visualize';\n\nexport default function compile(fxgl, fields, spec) {\n\n    // if(spec.hasOwnProperty('perceptual'))\n    //     operations.perceptual = kernels.perceptual(fxgl);\n    //\n    // if(spec.hasOwnProperty('derive'))\n    //     operations.derive = kernels.derive(fxgl, spec.derive);\n\n    return {\n        aggregate : aggregate(fxgl),\n        cache     : cache(fxgl),\n        match     : match(fxgl, fields),\n        extent    : extent(fxgl),\n        visualize : visualize(fxgl)\n        // perceive  : kernels.reveal(fxgl)\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/compile.js\n// module id = 26\n// module chunks = 0","import {seqFloat} from './utils';\n\nconst vecId = ['x', 'y', 'z'];\nconst aggrOpts = ['$min', '$max', '$count', '$sum', '$avg', '$var', '$std'];\n\nexport default function aggregate($p) {\n    var aggregate = {};\n\n    $p.uniform('uGroupGetStat', 'float', 0.0)\n        .uniform('uAggrOpt', 'int', 2);\n\n    function vertexShader() {\n        gl_PointSize = 1.0;\n\n        var i, j, k;\n        var x, groupKeyValue;\n\n        i = (this.aDataIdx + 0.5) / this.uDataDim.x;\n        j = (this.aDataIdy + 0.5) / this.uDataDim.y;\n        this.vResult = this.getData(this.uFieldId, i, j);\n\n        if (this.aDataIdy * this.uDataDim.x + this.aDataIdx >= this.uDataSize) {\n            this.vResult = 0.0;\n        }\n\n        if (this.uFilterFlag == 1) {\n            if (texture2D(this.fFilterResults, vec2(i, j)).a < this.uVisLevel - 0.01)\n                this.vResult = 0.0;\n        }\n\n        var pos = new Vec2();\n        for (var ii = 0; ii < 2; ii++) {\n            var gid = new Int();\n            gid = this.uGroupFields[ii];\n            if (gid != -1) {\n                if (this.uIndexCount > 0) {\n                    if (gid == 0) {\n                        groupKeyValue = i;\n                    } else if (gid == 1) {\n                        groupKeyValue = j;\n                    }\n                }\n                if (this.uIndexCount == 0 || gid > 1) {\n                    var d = new Vec2();\n                    d = this.getFieldDomain(gid);\n                    groupKeyValue = (this.getData(gid, i, j) - d.x) / (d.y - d.x) * (this.getFieldWidth(gid)) / (this.getFieldWidth(gid) + 1.);\n                    groupKeyValue += 0.5 / this.getFieldWidth(gid);\n                }\n                pos[ii] = groupKeyValue * 2.0 - 1.0;\n            } else {\n                pos[ii] = 0.5;\n            }\n        }\n\n        gl_Position = vec4(pos, 0.0, 1.0);\n    }\n\n    function fragmentShader() {\n        if (this.vResult == 0.0) discard;\n\n        if (this.uAggrOpt == 2)\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        else\n            gl_FragColor = vec4(0.0, 0.0, 1.0, this.vResult);\n    }\n\n    var vs = $p.shader.vertex(vertexShader),\n        fs = $p.shader.fragment(fragmentShader);\n\n    $p.program(\"group\", vs, fs);\n\n    var vs2 = $p.shader.vertex(function main() {\n        gl_Position = vec4(this._square, 0, 1);\n    });\n\n    var fs2 = $p.shader.fragment(function() {\n        var x, y, res;\n        $vec4(value);\n        x = (gl_FragCoord.x) / this.uResultDim.x;\n        y = (gl_FragCoord.y) / this.uResultDim.y;\n        y = (float(this.uFieldId - this.uIndexCount) + y) / float(this.uFieldCount);\n        value = texture2D(this.uDataInput, vec2(x, y));\n        if (this.uAggrOpt > 3)\n            res = value.a / value.b;\n        else\n            res = value.a;\n        gl_FragColor = vec4(0.0, 0.0, 0.0, res);\n    });\n\n    $p.program(\"group2\", vs2, fs2);\n\n    var resultFieldCount,\n        getAvgValues = false,\n        getVarStd = false,\n        resultDomains;\n\n    function _execute(opts, groupFieldIds, resultFieldIds) {\n        resultFieldCount = resultFieldIds.length;\n        var gl = $p.program(\"group\");\n        $p.bindFramebuffer(\"fGroupResults\");\n        $p.framebuffer.enableRead(\"fDerivedValues\");\n        $p.framebuffer.enableRead(\"fFilterResults\");\n\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n        gl.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n\n        $p.uniform.uGroupFields = groupFieldIds;\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        gl.disable(gl.CULL_FACE);\n        gl.disable(gl.DEPTH_TEST);\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.ONE, gl.ONE);\n        gl.blendEquation(gl.FUNC_ADD);\n        $p.uniform.uGroupGetStat = 0.0;\n        var resultDomains = new Array(resultFieldIds.length);\n        $p.uniform.uResultDim = $p.resultDimension;\n\n        getAvgValues = false;\n        getVarStd = false;\n        resultFieldIds.forEach(function(f, i) {\n            var opt = aggrOpts.indexOf(opts[i]);\n            if (opt == -1) throw Error(\"unknow operator for aggreation: \" + opts[i]);\n            gl.viewport(0, i * $p.resultDimension[1], $p.resultDimension[0], $p.resultDimension[1]);\n            if (opt == 0) gl.blendEquation(gl.MIN_EXT);\n            else if (opt == 1) gl.blendEquation(gl.MAX_EXT);\n            else gl.blendEquation(gl.FUNC_ADD);\n            $p.uniform.uFieldId = f;\n            $p.uniform.uAggrOpt = opt;\n            gl.ext.drawArraysInstancedANGLE(\n                gl.POINTS, 0,\n                $p.dataDimension[0],\n                $p.dataDimension[1]\n            );\n            if (opt > 3) {\n                getAvgValues = true;\n                if (opt > 4) getVarStd = true;\n            }\n        });\n\n        if (getAvgValues) {\n            // console.log('*** Second Pass for Aggregation');\n            var fieldCount = $p.uniform.uFieldCount.data,\n                preAggrData = $p.uniform.uDataInput.data;\n\n            $p.uniform.uDataInput.data = $p.framebuffer.fGroupResults.texture;\n            $p.uniform.uFieldCount.data = resultFieldIds.length;\n\n\n                $p.framebuffer(\n                    \"fAggrStats\",\n                    \"float\", [$p.resultDimension[0], $p.resultDimension[1] * resultFieldIds.length]\n                );\n                $p.bindFramebuffer(\"fAggrStats\");\n\n\n\n            gl = $p.program(\"group2\");\n            $p.framebuffer.enableRead(\"fGroupResults\");\n            gl.ext.vertexAttribDivisorANGLE($p.attribute._square.location, 0);\n\n            gl.disable(gl.BLEND);\n            resultFieldIds.forEach(function(f, i) {\n                var opt = aggrOpts.indexOf(opts[i]);\n                $p.uniform.uAggrOpt = opt;\n                $p.uniform.uFieldId = i;\n                gl.viewport(0, i * $p.resultDimension[1], $p.resultDimension[0], $p.resultDimension[1]);\n                gl.drawArrays(gl.TRIANGLES, 0, 6);\n            })\n            $p.uniform.uDataInput.data = $p.framebuffer.fAggrStats.texture;\n\n        } else {\n            $p.uniform.uDataInput.data = $p.framebuffer.fGroupResults.texture;\n\n        }\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    }\n\n    aggregate.execute = function(spec) {\n        var groupFields = spec.$by || spec.$group,\n            groupFieldIds = [-1, -1].\n        resultDim = [1, 1];\n\n        if (!Array.isArray(groupFields)) groupFields = [groupFields];\n        if (groupFields.length == 2) {\n            groupFieldIds[0] = $p.fields.indexOf(groupFields[0]);\n            groupFieldIds[1] = $p.fields.indexOf(groupFields[1]);\n            $p.resultDimension = [\n                $p.fieldWidths[groupFieldIds[0]],\n                $p.fieldWidths[groupFieldIds[1]]\n            ];\n        } else {\n            groupFieldIds[0] = $p.fields.indexOf(groupFields[0]);\n            $p.resultDimension = [$p.fieldWidths[groupFieldIds[0]], 1];\n        }\n\n\n        // console.log( groupFieldIds, $p.resultDimension, $p.fieldWidths, $p.fieldDomains);\n        // var resultFields = Object.keys(spec).filter(function(d){return d!='$by' && d!='$group';}),\n        //     resultFieldIds = resultFields.map(function(f) { return fields.indexOf(f); }),\n        //     operators = resultFields.map(function(r){return spec[r]; });\n\n\n        var newFieldSpec = spec.$calculate || spec.$reduce || spec.$out || null;\n\n        if (newFieldSpec === null) {\n            newFieldSpec = {};\n            Object.keys(spec).filter(function(d) {\n                return d != '$by' && d != '$group';\n            }).forEach(function(d) {\n                newFieldSpec[d] = spec[d];\n            });\n        }\n\n        var newFieldNames = Object.keys(newFieldSpec),\n            resultFields = newFieldNames.map(function(f) {\n                return newFieldSpec[f][Object.keys(newFieldSpec[f])[0]];\n            }),\n            resultFieldIds = resultFields.map(function(f) {\n                return $p.fields.indexOf(f);\n            }),\n            operators = resultFields.map(function(f, i) {\n                return Object.keys(newFieldSpec[newFieldNames[i]])[0];\n            });\n\n        if (!$p._update) {\n            $p.framebuffer(\n                \"fGroupResults\",\n                \"float\", [$p.resultDimension[0], $p.resultDimension[1] * resultFields.length]\n            );\n        }\n        _execute(operators, groupFieldIds, resultFieldIds);\n\n        $p.getResult = aggregate.result;\n        $p.indexes = groupFields;\n        $p.dataDimension = $p.resultDimension;\n\n        var newFieldIds = groupFieldIds.filter(function(f) {\n            return f !== -1\n        }).concat(resultFieldIds);\n\n        $p.fields = groupFields\n            .map(function(gf) {\n                return (gf.substring(0, 4) == 'bin@') ? gf.slice(4) : gf;\n            })\n            .concat(newFieldNames);\n\n        $p.uniform.uDataDim.data = $p.resultDimension;\n        $p.uniform.uIndexCount.data = $p.indexes.length;\n        $p.uniform.uFieldCount.data = $p.fields.length - $p.indexes.length;\n\n        // $p.fieldWidths = $p.fieldWidths.concat($p.deriveWidths);\n        // $p.fieldDomains = $p.fieldDomains.concat($p.deriveDomains);\n\n        $p.fieldDomains = newFieldIds.map(function(f) {\n            return $p.fieldDomains[f];\n        });\n        $p.fieldWidths = newFieldIds.map(function(f) {\n            return $p.fieldWidths[f];\n        });\n\n        // $p.uniform.uDataInput.data = $p.framebuffer.fGroupResults.texture;\n\n        $p.attribute.aDataItemId = seqFloat(0, $p.resultDimension[0] * $p.resultDimension[1] - 1);\n        $p.dataSize = $p.resultDimension[0] * $p.resultDimension[1];\n        $p.uniform.uDataSize.data = $p.dataSize;\n\n        $p.indexes.forEach(function(d, i) {\n            // $p.attribute['aDataId' + vecId[i]] = seqFloat(0, $p.resultDimension[i]-1);\n            $p.attribute['aDataId' + vecId[i]] = new Float32Array($p.resultDimension[i]).map(function(d, i) {\n                return i;\n            });\n            $p.attribute['aDataVal' + vecId[i]] = new Float32Array($p.resultDimension[i]).map(function(d, i) {\n                return i;\n            });\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataId' + vecId[i]].location, i);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataVal' + vecId[i]].location, i);\n        });\n\n        if ($p.indexes.length == 1) {\n            $p.attribute.aDataIdy = new Float32Array(1);\n            $p.attribute.aDataValy = new Float32Array(1);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n        }\n        if (!$p._update) {\n            resultDomains = $p.opt.extent(resultFieldIds, $p.dataDimension);\n        }\n        for (var ii = $p.indexes.length; ii < $p.indexes.length + resultFieldIds.length; ii++) {\n            $p.fieldDomains[ii] = resultDomains[ii - $p.indexes.length];\n            $p.fieldWidths[ii] = resultDomains[ii - $p.indexes.length][1] - resultDomains[ii - $p.indexes.length][0];\n        }\n\n        $p.uniform.uFieldDomains.data = $p.fieldDomains;\n        $p.uniform.uFieldWidths.data = $p.fieldWidths;\n        $p.uniform.uFilterFlag.data = 0;\n\n        $p.indexes.forEach(function(d, i) {\n            // $p.attribute['aDataId' + vecId[i]] = seqFloat(0, $p.resultDimension[i]-1);\n            var interval = 1;\n\n            if ($p.intervals.hasOwnProperty(d))\n                interval = $p.intervals[d].interval;\n\n            $p.attribute['aDataVal' + vecId[i]] = seqFloat(\n                $p.fieldDomains[i][0],\n                $p.fieldDomains[i][1],\n                interval\n            );\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataId' + vecId[i]].location, i);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute['aDataVal' + vecId[i]].location, i);\n        });\n    }\n\n    aggregate.result = function(arg) {\n        var options = arg || {},\n            offset = options.offset || [0, 0],\n            resultSize = options.size || $p.resultDimension[0] * $p.resultDimension[1],\n            rowTotal = Math.min(resultSize, $p.resultDimension[0]),\n            colTotal = Math.ceil(resultSize / $p.resultDimension[0]);\n\n        $p.bindFramebuffer(\"fGroupResults\");\n        var gl = $p.program(\"group\"),\n            result = new Float32Array(rowTotal * colTotal * 4 * resultFieldCount);\n\n        gl.readPixels(offset[0], offset[1], rowTotal, colTotal * resultFieldCount, gl.RGBA, gl.FLOAT, result);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return result.filter(function(d, i) {\n            return i % 4 === 3;\n        });\n    }\n\n    return aggregate;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/aggregate.js\n// module id = 27\n// module chunks = 0","export default function cache(fxgl) {\n    var cache = {},\n        dataDimension = fxgl.uniform.uDataDim.data,\n        fieldCount =  fxgl.uniform.uFieldCount.data,\n        cacheTag;\n\n    var vs = fxgl.shader.vertex(function () {\n         gl_Position = vec4(this._square, 0, 1);\n    });\n\n    var fs = fxgl.shader.fragment(function () {\n        var x, y;\n        $vec4(value);\n        x = (gl_FragCoord.x) / this.uDataDim.x;\n        y = (gl_FragCoord.y) / (this.uDataDim.y * float(this.uFieldCount));\n        value = texture2D(this.uDataInput, vec2(x, y));\n        gl_FragColor = value;\n    });\n\n    fxgl.program(\"cache\", vs, fs);\n\n    cache.execute = function(tag, dataDim, fieldTotal) {\n        cacheTag = tag;\n        dataDimension = dataDim || fxgl.uniform.uDataDim.data;\n        fieldCount = fieldTotal || fxgl.uniform.uFieldCount.data;\n\n        console.log(fieldCount);\n\n        fxgl.framebuffer(tag, \"float\", [dataDimension[0], dataDimension[1]*fieldCount]);\n        fxgl.bindFramebuffer(tag);\n        var gl = fxgl.program(\"cache\");\n\n        // console.log(dataDimension, fieldCount);\n        gl.viewport(0, 0, dataDimension[0], dataDimension[1]*fieldCount);\n        gl.clearColor( 0.0, 0.0, 0.0, 0.0 );\n        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n        gl.disable(gl.CULL_FACE);\n        gl.disable(gl.DEPTH_TEST);\n        gl.disable(gl.BLEND);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n        var result = new Float32Array(dataDimension[0]*dataDimension[1]*4*fieldCount);\n        gl.readPixels(0, 0, dataDimension[0], dataDimension[1]*fieldCount, gl.RGBA, gl.FLOAT, result);\n        console.log(result.filter(function(d, i){ return i%4===3 } ));\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        fxgl.framebuffer.enableRead(tag);\n        fxgl.uniform.uDataInput = fxgl.framebuffer[tag].texture;\n    }\n\n    cache.result =  function() {\n        fxgl.bindFramebuffer(cacheTag);\n        var gl = fxgl.program(\"cache\"),\n            result = new Float32Array(dataDimension[0]*dataDimension[1]*4*fieldCount);\n\n        gl.readPixels(0, 0, dataDimension[0], dataDimension[1]*fieldCount, gl.RGBA, gl.FLOAT, result);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return result.filter(function(d, i){ return i%4===0;} );\n    }\n\n    return cache;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/cache.js\n// module id = 28\n// module chunks = 0","function vertexShaderFilter(){\n    var i, j, k, value;\n    var filter = new Int(0);\n    var sel = new Int(0);\n    var visSelect = new Bool(false);\n    i = (this.aDataIdx+0.5) / this.uDataDim.x;\n    j = (this.aDataIdy+0.5) / this.uDataDim.y;\n\n    for(var f = 0; f < $(fieldCount)+$(indexCount); f++) {\n        if(this.uFilterControls[f] == 1 || this.uVisControls[f] == 1) {\n            value = this.getData(f, i, j);\n\n            if(this.uFilterControls[f] == 1) {\n                if(value < this.uFilterRanges[f].x || value >= this.uFilterRanges[f].y) {\n                    filter -= 1;\n                }\n            }\n            if(this.uVisControls[f] == 1) {\n                if(value < this.uVisRanges[f].x || value >= this.uVisRanges[f].y) {\n                    sel -= 1;\n                }\n                visSelect = true;\n            }\n\n        }\n    }\n    this.vResult = 0.1;\n    if(filter < 0) {\n        this.vResult = 0.0;\n    } else {\n        if(visSelect)\n            this.vResult = (sel < 0) ? 0.1 : 0.2;\n    }\n    var x = i * 2.0 - 1.0;\n    var y = j * 2.0 - 1.0;\n    gl_PointSize = 1.0;\n    gl_Position = vec4(x, y, 0.0, 1.0);\n}\n\nfunction vertexShaderSelect(){\n    var i, j, k, value;\n    i = (this.aDataIdx+0.5) / this.uDataDim.x;\n    j = (this.aDataIdy+0.5) / this.uDataDim.y;\n    this.vResult = this.uFilterLevel - 0.1;\n    value = this.getData(this.uFieldId, i, j);\n    for(var l = 0; l < 100; l++){\n        if(l < this.uSelectCount) {\n            if(value == this.uInSelections[l]) {\n                this.vResult = this.uFilterLevel;\n            }\n        }\n    }\n    var x = i * 2.0 - 1.0;\n    var y = j * 2.0 - 1.0;\n    gl_PointSize = 1.0;\n    gl_Position = vec4(x, y, 0.0, 1.0);\n}\n\nfunction fragmentShader() {\n    gl_FragColor = vec4(0., 0., 0., this.vResult);\n}\n\nexport default function match($p) {\n    const SELECT_MAX = 100;\n    var match = {},\n        dataDimension = $p.uniform.uDataDim.data,\n        fieldCount = $p.fields.length,\n        filterControls = new Array(fieldCount).fill(0),\n        filterRanges = $p.fieldDomains,\n        visControls = new Array(fieldCount).fill(0),\n        visRanges = $p.fieldDomains,\n        inSelections = new Array(SELECT_MAX);\n\n    $p.uniform(\"uFilterControls\",\"int\", filterControls)\n        .uniform(\"uVisControls\",\"int\", filterControls)\n        .uniform(\"uFilterRanges\",\"vec2\", filterRanges)\n        .uniform(\"uVisRanges\",\"vec2\", filterRanges)\n        .uniform(\"uInSelections\", \"float\", Float32Array.from(inSelections))\n        .uniform(\"uSelectMax\", \"int\", SELECT_MAX)\n        .uniform(\"uSelectCount\", \"int\", 0);\n\n    var filter = {\n        vs: $p.shader.vertex(vertexShaderFilter),\n        fs: $p.shader.fragment(fragmentShader)\n    };\n\n    var sel = {\n        vs: $p.shader.vertex(vertexShaderSelect),\n        fs: $p.shader.fragment(fragmentShader)\n    };\n\n    $p.program(\"filter\", filter.vs, filter.fs);\n    $p.program(\"match\", sel.vs, sel.fs);\n\n    match.control = function(ctrl) {\n        // filterControls = ctrl;\n    }\n\n    function _execute(spec){\n        var fields = $p.fields\n        var gl;\n        var matchFields = Object.keys(spec).filter(function(s){\n            return spec[s].hasOwnProperty('$in');\n        })\n        .concat(Object.keys($p.crossfilters).filter(function(s){\n            return $p.crossfilters[s].hasOwnProperty('$in');\n        }))\n\n\n        $p.bindFramebuffer(\"fFilterResults\");\n        $p.framebuffer.enableRead(\"fDerivedValues\");\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n        $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n        if(matchFields.length) {\n            gl = $p.program(\"match\");\n            gl.viewport(0, 0, dataDimension[0], dataDimension[1]);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n            gl.clearColor( 1.0, 1.0, 1.0, 1.0 );\n            gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n            gl.enable( gl.BLEND );\n            gl.blendFunc( gl.ONE, gl.ONE );\n            gl.blendEquation(gl.MIN_EXT);\n\n            matchFields.forEach(function(k){\n                var fieldId = fields.indexOf(k);\n                var inSelections = (spec.hasOwnProperty(k)) ? spec[k].$in :  $p.crossfilters[k].$in;\n                if($p.categoryIndex.hasOwnProperty(k)) {\n                    inSelections = inSelections\n                        .slice(0, SELECT_MAX)\n                        .map(function(v) { return $p.categoryIndex[k][v]; });\n                } else {\n                    inSelections = inSelections.slice(0, SELECT_MAX);\n                }\n                $p.uniform.uSelectCount = inSelections.length;\n                $p.uniform.uInSelections = Float32Array.from(inSelections);\n                $p.uniform.uFieldId = fieldId;\n\n                gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n                // filterRanges[fieldId*2] = Math.min.apply(null, spec[k].$in);\n                // filterRanges[fieldId*2+1] = Math.max.apply(null, spec[k].$in);\n                filterRanges[fieldId] = [Math.min.apply(null, inSelections), Math.max.apply(null, inSelections)];\n            })\n        }\n        // console.log($p._responseType, spec);\n        var filterSelections = Object.keys(spec).filter(function(s){\n            return !spec[s].hasOwnProperty('$in');\n        });\n\n        var viewSelections = Object.keys($p.crossfilters).filter(function(s){\n            return !$p.crossfilters[s].hasOwnProperty('$in');\n        });;\n\n        if(filterSelections.length || viewSelections.length){\n            filterControls = new Array(fieldCount).fill(0);\n\n            filterSelections.forEach(function(k){\n                var fieldId = fields.indexOf(k);\n\n                if(fieldId === -1) {\n                    console.log('Skipped: Matching on invalid data field ' + k);\n                    return;\n                }\n                if(spec[k].length < 2) spec[k][1] = spec[k][0];\n                filterControls[fieldId] = 1;\n                filterRanges[fieldId] = spec[k];\n                // filterRanges[fieldId*2] = spec[k][0];\n                // filterRanges[fieldId*2+1] = spec[k][1];\n            });\n\n            viewSelections.forEach(function(k){\n                var fieldId = fields.indexOf(k);\n                if(fieldId === -1) {\n                    console.log('Skipped: Matching on invalid data field ' + k);\n                    return;\n                }\n                if($p.crossfilters[k].length < 2) $p.crossfilters[k][1] = $p.crossfilters[k][0];\n                visControls[fieldId] = 1;\n                visRanges[fieldId] = $p.crossfilters[k];\n            });\n\n            $p.uniform.uFilterControls.data = filterControls;\n            $p.uniform.uFilterRanges.data = filterRanges;\n            $p.uniform.uVisControls.data = visControls;\n            $p.uniform.uVisRanges.data = visRanges;\n\n            gl = $p.program(\"filter\");\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n            gl.disable(gl.BLEND);\n            // gl.clearColor( 0.0, 0.0, 0.0, 0.0 );\n            // gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n\n            gl.viewport(0, 0, dataDimension[0], dataDimension[1]);\n            gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n        }\n        $p.ctx.bindFramebuffer($p.ctx.FRAMEBUFFER, null);\n        return filterRanges;\n    }\n\n    match.execute = function(spec) {\n        filterControls = new Array(fieldCount).fill(0);\n        visControls = new Array(fieldCount).fill(0);\n        var filterSpec = spec;\n\n\n        Object.keys($p.crossfilters).forEach(function(k, i) {\n            if($p.categoryIndex.hasOwnProperty(k) && !$p.crossfilters[k].$in) {\n                $p.crossfilters[k] = {$in: $p.crossfilters[k]};\n            }\n        });\n\n\n        Object.keys(filterSpec).forEach(function(k, i) {\n            if($p.categoryIndex.hasOwnProperty(k) && !spec[k].$in) {\n                spec[k] = {$in: spec[k]};\n            }\n        });\n\n        $p.uniform.uFilterFlag = 1;\n        if(!$p._update) {\n            filterRanges = $p.fieldDomains.slice();\n            visRanges = $p.fieldDomains.slice();\n        }\n        var newDomains = _execute(spec);\n\n        if(!$p._update){\n            // console.log('checking filter domains', newDomains);\n            newDomains.forEach(function(domain, fid) {\n                var d = domain;\n                if($p.dtypes[fid] == 'int') d[1] -= 1;\n                $p.fieldDomains[fid] = d;\n                $p.fieldWidths[fid] = $p.getDataWidth(fid, d);\n            });\n\n            $p.uniform.uFieldDomains.data = $p.fieldDomains;\n            $p.uniform.uFieldWidths.data = $p.fieldWidths;\n        }\n    }\n\n    match.result = function(arg) {\n        var options = arg || {},\n            offset = options.offset || [0, 0],\n            resultSize = options.size || $p.dataDimension[0]* $p.dataDimension[1],\n            rowSize = Math.min(resultSize, $p.dataDimension[0]),\n            colSize = Math.ceil(resultSize/$p.dataDimension[0]);\n\n        $p.bindFramebuffer(\"fFilterResults\");\n\n        var gl = $p.ctx;\n        var bitmap = new Uint8Array(rowSize*colSize*4);\n        gl.readPixels(offset[0], offset[1], rowSize, colSize, gl.RGBA, gl.UNSIGNED_BYTE, bitmap);\n        // console.log(result.filter(function(d, i){ return i%4===0;} ));\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        // var result = [];\n        // bitmap.forEach(function(d, i){ if(i%3===0 && d!==0) result.push(d);});\n        // console.log(result);\n        // return result;\n        return  bitmap;\n    }\n\n    return match;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/match.js\n// module id = 29\n// module chunks = 0","\nconst smallest = -Math.pow(2, 128);\nexport default function extent(fxgl) {\n\n    var fieldCount = fxgl.uniform.uFieldCount.data;\n    fxgl.framebuffer(\"fStats\", \"float\", [2, fieldCount]);\n\n    var vs = fxgl.shader.vertex(function() {\n        gl_PointSize = 1.0;\n        var i, j;\n        if (this.aDataIdy * this.uDataDim.x + this.aDataIdx >= this.uDataSize) {\n            this.vDiscardData = 1.0;\n        } else {\n            this.vDiscardData = 0.0;\n            i = (this.aDataIdx + 0.5) / this.uDataDim.x;\n            j = (this.aDataIdy + 0.5) / this.uDataDim.y;\n            this.vResult = this.getData(this.uFieldId, i, j);\n        }\n        gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    });\n\n    var fs = fxgl.shader.fragment(function() {\n        if (this.vDiscardData == 1.0) discard;\n        if (this.vResult >= 0.0) {\n            gl_FragColor = vec4(0.0, 0.0, 1.0, this.vResult);\n        } else {\n            gl_FragColor = vec4(-1.0, this.vResult, 0.0, 0.0);\n        }\n    });\n\n    var gl = fxgl.program(\"stats\", vs, fs);\n\n    return function(fieldIds, dataDimension) {\n        if (!fxgl._update) {\n            fxgl.framebuffer(\"fStats\", \"float\", [2, fieldIds.length]);\n        }\n        var gl = fxgl.program(\"stats\");\n        fxgl.framebuffer.enableRead(\"fGroupResults\");\n\n        gl.ext.vertexAttribDivisorANGLE(fxgl.attribute.aDataIdx.location, 0);\n        gl.ext.vertexAttribDivisorANGLE(fxgl.attribute.aDataValx.location, 0);\n        gl.ext.vertexAttribDivisorANGLE(fxgl.attribute.aDataIdy.location, 1);\n        gl.ext.vertexAttribDivisorANGLE(fxgl.attribute.aDataValy.location, 1);\n\n        fxgl.bindFramebuffer(\"fStats\");\n        gl.clearColor(smallest, smallest, smallest, smallest);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        gl.disable(gl.CULL_FACE);\n        gl.disable(gl.DEPTH_TEST);\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.ONE, gl.ONE);\n        // gl.finish();\n        // fxgl.uniform.uDeriveCount = deriveFieldCount;\n        var extents = new Array(fieldIds.length);\n        var start = new Date();\n        var idCount = fxgl.uniform.uIndexCount.data;\n        fieldIds.forEach(function(d, i) {\n            fxgl.uniform.uFieldId = i + idCount;\n            gl.viewport(0, i, 1, 1);\n            gl.blendEquation(gl.MAX_EXT);\n            gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n            // gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, max);\n\n            gl.viewport(1, i, 1, 1);\n            gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n\n            gl.blendEquation(gl.MIN_EXT);\n            gl.ext.drawArraysInstancedANGLE(gl.POINTS, 0, dataDimension[0], dataDimension[1]);\n\n            // var extent = new Float32Array(8);\n            // gl.readPixels(0, i, 2, 1, gl.RGBA, gl.FLOAT, extent);\n            // console.log(extent);\n            // var ext = extent;\n            // var minValue = (ext[0] > 0) ? ext[1] : ext[7],\n            //     maxValue = (ext[2] > 0) ? ext[3] : ext[5];\n            //  extents[i] = [minValue, maxValue];\n        });\n        var extent = new Float32Array(8 * fieldIds.length);\n        gl.readPixels(0, 0, 2, fieldIds.length, gl.RGBA, gl.FLOAT, extent);\n        fieldIds.forEach(function(d, i) {\n            var ext = extent.slice(i * 8, i * 8 + 8);\n            var minValue = (ext[4] < 0) ? ext[5] : ext[7],\n                maxValue = (ext[2] > 0) ? ext[3] : ext[1];\n            extents[i] = [minValue, maxValue];\n        });\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return extents;\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/extent.js\n// module id = 30\n// module chunks = 0","import colors from './color';\nimport ctypes from './ctypes';\nimport render from './render';\nimport reveal from './reveal';\nimport encode from './encode';\nimport interact from './interact';\n\nimport Layout from './metavis/layout';\n\nconst visualEncodings = ['x', 'y', 'color', 'opacity', 'width', 'height', 'size'];\nconst userActions = ['click', 'hover', 'brush', 'zoom', 'pan'];\n\nexport default function visualize($p) {\n\n    var colorManager = colors($p),\n        chartPadding = $p.padding || {left: 0, right: 0, top: 0, bottom: 0},\n        viewport = [\n            $p.viewport[0],\n            $p.viewport[1],\n        ];\n\n    var vis = new Layout({\n        container: $p.container,\n        width: viewport[0] + chartPadding.left + chartPadding.right,\n        height: viewport[1] + chartPadding.top + chartPadding.bottom,\n        canvas: $p.canvas,\n        padding: chartPadding\n    });\n\n    $p.uniform('uVisualEncodings',  'int',   new Array(visualEncodings.length).fill(-1))\n        .uniform('uViewDim',        'vec2',  $p.viewport)\n        .uniform('uVisShape',       'int',   1)\n        .uniform('uInterleaveX',    'int',   0)\n        .uniform('uVisDomains',     'vec2',  $p.fieldDomains.map(d=>d.slice()))\n        .uniform('uVisScale',       'vec2', [1.0, 1.0])\n        .uniform('uPosOffset',      'vec2', [0.0, 0.0])\n        .uniform('uFeatureCount',   'int',   0)\n        .uniform('uMarkSize',       'float', 10.0)\n        .uniform('uMarkSpace',      'vec2',  [0.02, 0.02])\n        .uniform('uDefaultAlpha',   'float', 1.0)\n        .uniform('uDefaultWidth',   'float', 1.0 / $p.viewport[0])\n        .uniform('uDefaultHeight',  'float', 1.0 / $p.viewport[1])\n        .uniform('uMaxRGBA',        'vec4',  [0, 0, 0, 0])\n        .uniform('uDefaultColor',   'vec3',  [0.8, 0, 0])\n        .uniform('uColorMode',      'int',   1)\n        .varying('vColorRGBA',      'vec4'   );\n\n    var enhance = reveal($p);\n\n    $p.framebuffer('offScreenFBO', 'float', $p.viewport);\n    $p.framebuffer('visStats', 'float', [1, 1]);\n\n    // $p.framebuffer.enableRead('offScreenFBO');\n    $p.renderMode = 'instancedXY';\n\n    var renderer = render($p);\n\n    function updateInstancedAttribute(vm) {\n        if(Array.isArray(vm)){\n            $p.uniform.uFeatureCount = vm.length;\n            var fv = new Float32Array(vm.length*2);\n            vm.forEach(function(f, i) {\n                fv[i*2] = $p.fields.indexOf(f);\n                fv[i*2+1] = i;\n            });\n            $p.attribute.aDataFieldId = fv;\n        }\n    }\n\n    var viz = function(options) {\n        $p.renderMode = 'instancedXY';\n        $p.revealDensity = false;\n        var vmap = options.vmap || {},\n            mark = options.mark || vmap.mark || 'line',\n            data = options.data || null,\n            interaction = options.interaction,\n            viewIndex = options.viewIndex,\n            viewTag = $p.views[viewIndex].id;\n\n        var visDomain = {},\n            visDimension = vmap.viewport || [$p.views[viewIndex].width, $p.views[viewIndex].height] || viewport;\n\n        var width = visDimension[0],\n            height =  visDimension[1],\n            padding = $p.views[viewIndex].padding || chartPadding,\n            offset = $p.views[viewIndex].offset || [0, 0];\n\n\n        var dimSetting = encode($p, vmap, colorManager);\n\n        if(!$p._update){\n            $p.fields.forEach(function(f, i){\n                visDomain[f] = $p.fieldDomains[i].slice();\n                if(vmap.zero && (f == vmap.height || f == vmap.width ) && visDomain[f][0]>0) visDomain[f][0] = 0;\n            });\n        }\n\n        var gl = $p.program($p.renderMode);\n        $p.framebuffer.enableRead('fFilterResults');\n        $p.framebuffer.enableRead('fDerivedValues');\n        $p.framebuffer.enableRead('fGroupResults');\n\n        if($p.renderMode == 'instancedXY') {\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdx.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValx.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataIdy.location, 1);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataValy.location, 1);\n        } else if($p.renderMode == 'interleave') {\n            updateInstancedAttribute(vmap.x);\n            updateInstancedAttribute(vmap.y);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataFieldId.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataItemId.location, 1);\n        } else {\n            var val0 = new Float32Array($p.dataSize),\n                val1 = new Float32Array($p.dataSize);\n            for(var y = 0; y < $p.dataDimension[1]; y++) {\n                for(var x = 0; x < $p.dataDimension[0]; x++) {\n                    val0[y*$p.dataDimension[0] + x] = $p.attribute.aDataValx.data[x];\n                    val1[y*$p.dataDimension[0] + x] = $p.attribute.aDataValy.data[y];\n                }\n            }\n            $p.attribute.aDataItemVal0 = val0;\n            $p.attribute.aDataItemVal1 = val1;\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aVertexId.location, 0);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataItemId.location, 1);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataItemVal0.location, 1);\n            $p.ctx.ext.vertexAttribDivisorANGLE($p.attribute.aDataItemVal1.location, 1);\n        }\n\n        // if(typeof data == 'string')\n        //     $p.uniform.uDataInput = $p.framebuffer[data].texture;\n        var viewSetting = {\n            domain: visDomain,\n            width: width,\n            height: height,\n            fields: $p.fields,\n            vmap: vmap,\n            onclick: interaction,\n            categories: $p.categoryLookup,\n            padding: padding,\n            left: offset[0],\n            top: viewport[1] - height - offset[1],\n            colors: colorManager.getColors(),\n            showLegend: $p.views[viewIndex].legend\n        };\n\n        viewSetting = Object.assign(viewSetting, dimSetting);\n\n        if($p.revealDensity) {\n            $p.bindFramebuffer('offScreenFBO');\n            gl.clearColor( 1.0, 1.0, 1.0, 0.0 );\n            gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n            gl.blendFunc(gl.ONE, gl.ONE );\n        } else {\n            $p.bindFramebuffer(null);\n            // gl.clearColor( 1.0, 1.0, 1.0, 0.0 );\n            gl.blendFunc( gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n            // gl.blendFunc(gl.SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);\n        }\n\n        gl.viewport(\n            offset[0] + padding.left,\n            offset[1] + padding.bottom,\n            width-padding.left-padding.right,\n            height-padding.top-padding.bottom\n        );\n        gl.lineWidth(1.0);\n\n        gl.disable(gl.CULL_FACE);\n        gl.disable(gl.DEPTH_TEST);\n        gl.enable( gl.BLEND );\n        gl.blendEquation(gl.FUNC_ADD);\n\n        if(mark == 'stack') {\n            var result = $p.readResult('row');\n            viewSetting.data = result.filter(d=>d[vmap.y]>0);\n            viewSetting.fields = $p.fields;\n            if($p.intervals.hasOwnProperty(vmap.x))\n                viewSetting.isHistogram = true;\n        }\n\n        //TODO: Maybe just save the needed data domains instead of copying all\n        if(!$p._update) {\n            var pv = $p.views[viewIndex];\n            pv.domains = Object.keys(visDomain).map(f=>visDomain[f]);\n            $p.uniform.uVisDomains = pv.domains;\n            if(pv.hasOwnProperty('chart') && typeof pv.chart.svg.remove == 'function') {\n                pv.chart.svg.remove();\n            }\n            pv.chart = vis.addChart(viewSetting);\n        } else {\n            $p.uniform.uVisDomains = $p.views[viewIndex].domains;\n            if(mark == 'stack'){\n                var result = $p.readResult('row');\n                $p.views[viewIndex].chart.update({\n                    data: result\n                })\n            }\n        }\n        var primitive = gl.POINTS;\n        if(['rect', 'bar'].indexOf(mark) !== -1) primitive = gl.TRIANGLES;\n        else if(mark == 'line') primitive = gl.LINE_STRIP;\n\n        function draw() {\n            if($p.renderMode == 'interleave') {\n                var count = $p.attribute.aDataFieldId.data.length / $p.attribute.aDataFieldId.size;\n                gl.ext.drawArraysInstancedANGLE(primitive, 0, count, $p.dataSize);\n            } else if($p.renderMode == 'polygon'){\n                gl.ext.drawArraysInstancedANGLE(primitive, 0, 6, $p.dataSize);\n            } else {\n                if(primitive == gl.LINE_STRIP) {\n                    console.log($p.dataDimension);\n                    gl.ext.drawArraysInstancedANGLE(primitive, 0, $p.dataDimension[0], $p.dataDimension[1]);\n                } else {\n                    gl.ext.drawArraysInstancedANGLE(primitive, 0, $p.dataDimension[0], $p.dataDimension[1]);\n                }\n            }\n        }\n\n        if(mark!='stack') draw();\n        if($p.revealDensity) enhance({\n            viewIndex: viewIndex,\n            dim: [width, height],\n            offset: offset,\n            padding: padding\n        });\n        $p.bindFramebuffer(null);\n\n        if(!$p._update) {\n            var actions = Object.keys(vmap)\n                .filter(function(act){ return userActions.indexOf(act) !== -1});\n\n            actions.forEach(function(action) {\n                var viewId = vmap.id || $p.views[viewIndex].id,\n                    response = {};\n                response[viewId] = vmap[action];\n                $p.interactions.push({\n                    event: action,\n                    condition: vmap[action].condition,\n                    from: viewId,\n                    response: response\n                })\n            })\n        }\n    }\n    viz.chart = vis;\n    return viz;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/visualize.js\n// module id = 31\n// module chunks = 0","import {gradients as colorSchemes} from './gradients';\nimport {colorhex} from './colorhex';\n\nconst colorResolution = 256;\nconst colorSetMax = 32;\nconst defaultColorScheme = colorSchemes['viridis'];\nconst defaultColorSet = [\n    [255,187,120], [255,127, 14], [174,199,232], [ 44,160, 44],\n    [ 31,119,180], [255,152,150], [214, 39, 40], [197,176,213],\n    [152,223,138], [148,103,189], [247,182,210], [227,119,194],\n    [196,156,148], [140, 86, 75], [127,127,127], [219,219,141],\n    [199,199,199], [188,189, 34], [158,218,229], [ 23,190,207]\n];\n\nvar gradient = defaultColorScheme,\n    colorset = defaultColorSet;\n\nexport default function color($p) {\n    var colorManager = {};\n\n    $p.uniform('uColorMode',       'int',   0) // 0=categorical, 1=numeric\n        .uniform('uColorCount',    'int',   colorSetMax)\n        .uniform('uColorSet',      'vec3',  setColorTable(colorset))\n        .texture('tColorGraident', 'float', setColorScheme(gradient),  [colorResolution, 1], 'rgba')\n        .subroutine('mapColorRGB', 'vec3',  mapColorRGB);\n\n    colorManager.updateScheme = function(newColors) {\n        if(typeof newColors == 'string' && colorSchemes.hasOwnProperty(newColors)) {\n            gradient = colorSchemes[newColors];\n        } else if(Array.isArray(newColors)) {\n            gradient = newColors;\n        }\n        $p.texture.tColorGraident = setColorScheme(gradient);\n    }\n\n    colorManager.updateTable = function(colors) {\n        colorset = colors;\n        $p.uniform.uColorSet = setColorTable(colors);\n    }\n\n    colorManager.colorTable = defaultColorSet.map(function(t){\n        return rgba2hex(t);\n    });\n\n    colorManager.getColors = function() {\n        if($p.uniform.uColorMode == 0) {\n            return colorset;\n        } else {\n            return gradient;\n        }\n    }\n\n    colorManager.rgb = rgb;\n    colorManager.rgba = rgba;\n\n    return colorManager;\n}\n\nfunction colorStrToHex(colorStr) {\n    if (typeof colorhex[colorStr.toLowerCase()] != 'undefined')\n        return colorhex[colorStr.toLowerCase()];\n    else\n        return false;\n}\n\nfunction rgb(hexStr) {\n    var hex, r, g, b;\n\n    if(hexStr.slice(0,1) == '#')\n        hex = hexStr.slice(1);\n    else\n        hex = colorStrToHex(hexStr).slice(1);\n\n    r = parseInt(hex.substring(0,2), 16) / 255;\n    g = parseInt(hex.substring(2,4), 16) / 255;\n    b = parseInt(hex.substring(4,6), 16) / 255;\n    return [r, g, b];\n}\n\nfunction rgba(hexStr, alpha) {\n    var a = alpha || 1.0,\n        c = rgb(hexStr);\n\n    return [c[0], c[1], c[2], a];\n}\n\nfunction rgba2hex(c) {\n    var r = c[0],\n        g = c[1],\n        b = c[2],\n        a = 1;\n    if (r > 255 || g > 255 || b > 255 || a > 255)\n        throw 'Invalid color component';\n    return (256 + r).toString(16).substr(1) +((1 << 24) + (g << 16) | (b << 8) | a).toString(16).substr(1);\n}\n\nfunction setColorScheme(colors) {\n    var cc = colors.length - 1,\n        step = (cc >= 0) ? colorResolution / (cc+1) : 1,\n        colorGradient = new Float32Array(colorResolution * 4);\n\n    colors.push(colors[cc]);\n    for(var i = 0; i < cc+1; i++) {\n        var c0 = rgba(colors[i]),\n            c1 = rgba(colors[i+1]),\n            offset = Math.floor(i * step)*4;\n\n        for(var x = 0; x < step; x++) {\n            var xi = x / (step);\n            colorGradient[offset+x*4]   = c0[0] + (c1[0] - c0[0]) * xi;\n            colorGradient[offset+x*4+1] = c0[1] + (c1[1] - c0[1]) * xi;\n            colorGradient[offset+x*4+2] = c0[2] + (c1[2] - c0[2]) * xi;\n            colorGradient[offset+x*4+3] = c0[3] + (c1[3] - c0[3]) * xi;\n        }\n    }\n    colors.pop();\n    return colorGradient;\n}\n\nfunction setColorTable(colors) {\n    var colorTable = new Float32Array(colorSetMax * 3),\n        isRgb = false;\n\n    if(colors[0].length == 3) isRgb = true;\n    colors.forEach(function(c, i){\n        var colorValue = c;\n        if(!isRgb) colorValue = rgb(c) * 255;\n        colorTable[i*3] = colorValue[0] / 255;\n        colorTable[i*3+1] = colorValue[1] / 255;\n        colorTable[i*3+2] = colorValue[2] / 255;\n    });\n\n    return colorTable;\n}\n\nfunction mapColorRGB($int_fieldId, $float_value) {\n    var d = new Vec2();\n    var colorRGB = new Vec3();\n    var intValue = new Int();\n    if(fieldId == -1) {\n        colorRGB = this.uDefaultColor;\n    } else {\n        if(this.uColorMode == 1) {\n            colorRGB = texture2D(this.tColorGraident, vec2(value, 1.0)).rgb;\n        } else {\n            d = this.uVisDomains[fieldId];\n            intValue = int(value * (d.y - d.x) + d.x);\n            if(intValue >= this.uColorCount) {\n                colorRGB = vec3(0.0, 0.0, 0.0);\n            } else {\n                colorRGB = this.uColorSet[intValue];\n            }\n        }\n    }\n    return colorRGB;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/color.js\n// module id = 32\n// module chunks = 0","export const gradients = {\n    \"inferno\": [\"#000004\", \"#010005\", \"#010106\", \"#010108\", \"#02010a\", \"#02020c\", \"#02020e\", \"#030210\", \"#040312\", \"#040314\", \"#050417\", \"#060419\", \"#07051b\", \"#08051d\", \"#09061f\", \"#0a0722\", \"#0b0724\", \"#0c0826\", \"#0d0829\", \"#0e092b\", \"#10092d\", \"#110a30\", \"#120a32\", \"#140b34\", \"#150b37\", \"#160b39\", \"#180c3c\", \"#190c3e\", \"#1b0c41\", \"#1c0c43\", \"#1e0c45\", \"#1f0c48\", \"#210c4a\", \"#230c4c\", \"#240c4f\", \"#260c51\", \"#280b53\", \"#290b55\", \"#2b0b57\", \"#2d0b59\", \"#2f0a5b\", \"#310a5c\", \"#320a5e\", \"#340a5f\", \"#360961\", \"#380962\", \"#390963\", \"#3b0964\", \"#3d0965\", \"#3e0966\", \"#400a67\", \"#420a68\", \"#440a68\", \"#450a69\", \"#470b6a\", \"#490b6a\", \"#4a0c6b\", \"#4c0c6b\", \"#4d0d6c\", \"#4f0d6c\", \"#510e6c\", \"#520e6d\", \"#540f6d\", \"#550f6d\", \"#57106e\", \"#59106e\", \"#5a116e\", \"#5c126e\", \"#5d126e\", \"#5f136e\", \"#61136e\", \"#62146e\", \"#64156e\", \"#65156e\", \"#67166e\", \"#69166e\", \"#6a176e\", \"#6c186e\", \"#6d186e\", \"#6f196e\", \"#71196e\", \"#721a6e\", \"#741a6e\", \"#751b6e\", \"#771c6d\", \"#781c6d\", \"#7a1d6d\", \"#7c1d6d\", \"#7d1e6d\", \"#7f1e6c\", \"#801f6c\", \"#82206c\", \"#84206b\", \"#85216b\", \"#87216b\", \"#88226a\", \"#8a226a\", \"#8c2369\", \"#8d2369\", \"#8f2469\", \"#902568\", \"#922568\", \"#932667\", \"#952667\", \"#972766\", \"#982766\", \"#9a2865\", \"#9b2964\", \"#9d2964\", \"#9f2a63\", \"#a02a63\", \"#a22b62\", \"#a32c61\", \"#a52c60\", \"#a62d60\", \"#a82e5f\", \"#a92e5e\", \"#ab2f5e\", \"#ad305d\", \"#ae305c\", \"#b0315b\", \"#b1325a\", \"#b3325a\", \"#b43359\", \"#b63458\", \"#b73557\", \"#b93556\", \"#ba3655\", \"#bc3754\", \"#bd3853\", \"#bf3952\", \"#c03a51\", \"#c13a50\", \"#c33b4f\", \"#c43c4e\", \"#c63d4d\", \"#c73e4c\", \"#c83f4b\", \"#ca404a\", \"#cb4149\", \"#cc4248\", \"#ce4347\", \"#cf4446\", \"#d04545\", \"#d24644\", \"#d34743\", \"#d44842\", \"#d54a41\", \"#d74b3f\", \"#d84c3e\", \"#d94d3d\", \"#da4e3c\", \"#db503b\", \"#dd513a\", \"#de5238\", \"#df5337\", \"#e05536\", \"#e15635\", \"#e25734\", \"#e35933\", \"#e45a31\", \"#e55c30\", \"#e65d2f\", \"#e75e2e\", \"#e8602d\", \"#e9612b\", \"#ea632a\", \"#eb6429\", \"#eb6628\", \"#ec6726\", \"#ed6925\", \"#ee6a24\", \"#ef6c23\", \"#ef6e21\", \"#f06f20\", \"#f1711f\", \"#f1731d\", \"#f2741c\", \"#f3761b\", \"#f37819\", \"#f47918\", \"#f57b17\", \"#f57d15\", \"#f67e14\", \"#f68013\", \"#f78212\", \"#f78410\", \"#f8850f\", \"#f8870e\", \"#f8890c\", \"#f98b0b\", \"#f98c0a\", \"#f98e09\", \"#fa9008\", \"#fa9207\", \"#fa9407\", \"#fb9606\", \"#fb9706\", \"#fb9906\", \"#fb9b06\", \"#fb9d07\", \"#fc9f07\", \"#fca108\", \"#fca309\", \"#fca50a\", \"#fca60c\", \"#fca80d\", \"#fcaa0f\", \"#fcac11\", \"#fcae12\", \"#fcb014\", \"#fcb216\", \"#fcb418\", \"#fbb61a\", \"#fbb81d\", \"#fbba1f\", \"#fbbc21\", \"#fbbe23\", \"#fac026\", \"#fac228\", \"#fac42a\", \"#fac62d\", \"#f9c72f\", \"#f9c932\", \"#f9cb35\", \"#f8cd37\", \"#f8cf3a\", \"#f7d13d\", \"#f7d340\", \"#f6d543\", \"#f6d746\", \"#f5d949\", \"#f5db4c\", \"#f4dd4f\", \"#f4df53\", \"#f4e156\", \"#f3e35a\", \"#f3e55d\", \"#f2e661\", \"#f2e865\", \"#f2ea69\", \"#f1ec6d\", \"#f1ed71\", \"#f1ef75\", \"#f1f179\", \"#f2f27d\", \"#f2f482\", \"#f3f586\", \"#f3f68a\", \"#f4f88e\", \"#f5f992\", \"#f6fa96\", \"#f8fb9a\", \"#f9fc9d\", \"#fafda1\", \"#fcffa4\"],\n    \"magma\": [\"#000004\", \"#010005\", \"#010106\", \"#010108\", \"#020109\", \"#02020b\", \"#02020d\", \"#03030f\", \"#030312\", \"#040414\", \"#050416\", \"#060518\", \"#06051a\", \"#07061c\", \"#08071e\", \"#090720\", \"#0a0822\", \"#0b0924\", \"#0c0926\", \"#0d0a29\", \"#0e0b2b\", \"#100b2d\", \"#110c2f\", \"#120d31\", \"#130d34\", \"#140e36\", \"#150e38\", \"#160f3b\", \"#180f3d\", \"#19103f\", \"#1a1042\", \"#1c1044\", \"#1d1147\", \"#1e1149\", \"#20114b\", \"#21114e\", \"#221150\", \"#241253\", \"#251255\", \"#271258\", \"#29115a\", \"#2a115c\", \"#2c115f\", \"#2d1161\", \"#2f1163\", \"#311165\", \"#331067\", \"#341069\", \"#36106b\", \"#38106c\", \"#390f6e\", \"#3b0f70\", \"#3d0f71\", \"#3f0f72\", \"#400f74\", \"#420f75\", \"#440f76\", \"#451077\", \"#471078\", \"#491078\", \"#4a1079\", \"#4c117a\", \"#4e117b\", \"#4f127b\", \"#51127c\", \"#52137c\", \"#54137d\", \"#56147d\", \"#57157e\", \"#59157e\", \"#5a167e\", \"#5c167f\", \"#5d177f\", \"#5f187f\", \"#601880\", \"#621980\", \"#641a80\", \"#651a80\", \"#671b80\", \"#681c81\", \"#6a1c81\", \"#6b1d81\", \"#6d1d81\", \"#6e1e81\", \"#701f81\", \"#721f81\", \"#732081\", \"#752181\", \"#762181\", \"#782281\", \"#792282\", \"#7b2382\", \"#7c2382\", \"#7e2482\", \"#802582\", \"#812581\", \"#832681\", \"#842681\", \"#862781\", \"#882781\", \"#892881\", \"#8b2981\", \"#8c2981\", \"#8e2a81\", \"#902a81\", \"#912b81\", \"#932b80\", \"#942c80\", \"#962c80\", \"#982d80\", \"#992d80\", \"#9b2e7f\", \"#9c2e7f\", \"#9e2f7f\", \"#a02f7f\", \"#a1307e\", \"#a3307e\", \"#a5317e\", \"#a6317d\", \"#a8327d\", \"#aa337d\", \"#ab337c\", \"#ad347c\", \"#ae347b\", \"#b0357b\", \"#b2357b\", \"#b3367a\", \"#b5367a\", \"#b73779\", \"#b83779\", \"#ba3878\", \"#bc3978\", \"#bd3977\", \"#bf3a77\", \"#c03a76\", \"#c23b75\", \"#c43c75\", \"#c53c74\", \"#c73d73\", \"#c83e73\", \"#ca3e72\", \"#cc3f71\", \"#cd4071\", \"#cf4070\", \"#d0416f\", \"#d2426f\", \"#d3436e\", \"#d5446d\", \"#d6456c\", \"#d8456c\", \"#d9466b\", \"#db476a\", \"#dc4869\", \"#de4968\", \"#df4a68\", \"#e04c67\", \"#e24d66\", \"#e34e65\", \"#e44f64\", \"#e55064\", \"#e75263\", \"#e85362\", \"#e95462\", \"#ea5661\", \"#eb5760\", \"#ec5860\", \"#ed5a5f\", \"#ee5b5e\", \"#ef5d5e\", \"#f05f5e\", \"#f1605d\", \"#f2625d\", \"#f2645c\", \"#f3655c\", \"#f4675c\", \"#f4695c\", \"#f56b5c\", \"#f66c5c\", \"#f66e5c\", \"#f7705c\", \"#f7725c\", \"#f8745c\", \"#f8765c\", \"#f9785d\", \"#f9795d\", \"#f97b5d\", \"#fa7d5e\", \"#fa7f5e\", \"#fa815f\", \"#fb835f\", \"#fb8560\", \"#fb8761\", \"#fc8961\", \"#fc8a62\", \"#fc8c63\", \"#fc8e64\", \"#fc9065\", \"#fd9266\", \"#fd9467\", \"#fd9668\", \"#fd9869\", \"#fd9a6a\", \"#fd9b6b\", \"#fe9d6c\", \"#fe9f6d\", \"#fea16e\", \"#fea36f\", \"#fea571\", \"#fea772\", \"#fea973\", \"#feaa74\", \"#feac76\", \"#feae77\", \"#feb078\", \"#feb27a\", \"#feb47b\", \"#feb67c\", \"#feb77e\", \"#feb97f\", \"#febb81\", \"#febd82\", \"#febf84\", \"#fec185\", \"#fec287\", \"#fec488\", \"#fec68a\", \"#fec88c\", \"#feca8d\", \"#fecc8f\", \"#fecd90\", \"#fecf92\", \"#fed194\", \"#fed395\", \"#fed597\", \"#fed799\", \"#fed89a\", \"#fdda9c\", \"#fddc9e\", \"#fddea0\", \"#fde0a1\", \"#fde2a3\", \"#fde3a5\", \"#fde5a7\", \"#fde7a9\", \"#fde9aa\", \"#fdebac\", \"#fcecae\", \"#fceeb0\", \"#fcf0b2\", \"#fcf2b4\", \"#fcf4b6\", \"#fcf6b8\", \"#fcf7b9\", \"#fcf9bb\", \"#fcfbbd\", \"#fcfdbf\"],\n    \"plasma\": [\"#0d0887\", \"#100788\", \"#130789\", \"#16078a\", \"#19068c\", \"#1b068d\", \"#1d068e\", \"#20068f\", \"#220690\", \"#240691\", \"#260591\", \"#280592\", \"#2a0593\", \"#2c0594\", \"#2e0595\", \"#2f0596\", \"#310597\", \"#330597\", \"#350498\", \"#370499\", \"#38049a\", \"#3a049a\", \"#3c049b\", \"#3e049c\", \"#3f049c\", \"#41049d\", \"#43039e\", \"#44039e\", \"#46039f\", \"#48039f\", \"#4903a0\", \"#4b03a1\", \"#4c02a1\", \"#4e02a2\", \"#5002a2\", \"#5102a3\", \"#5302a3\", \"#5502a4\", \"#5601a4\", \"#5801a4\", \"#5901a5\", \"#5b01a5\", \"#5c01a6\", \"#5e01a6\", \"#6001a6\", \"#6100a7\", \"#6300a7\", \"#6400a7\", \"#6600a7\", \"#6700a8\", \"#6900a8\", \"#6a00a8\", \"#6c00a8\", \"#6e00a8\", \"#6f00a8\", \"#7100a8\", \"#7201a8\", \"#7401a8\", \"#7501a8\", \"#7701a8\", \"#7801a8\", \"#7a02a8\", \"#7b02a8\", \"#7d03a8\", \"#7e03a8\", \"#8004a8\", \"#8104a7\", \"#8305a7\", \"#8405a7\", \"#8606a6\", \"#8707a6\", \"#8808a6\", \"#8a09a5\", \"#8b0aa5\", \"#8d0ba5\", \"#8e0ca4\", \"#8f0da4\", \"#910ea3\", \"#920fa3\", \"#9410a2\", \"#9511a1\", \"#9613a1\", \"#9814a0\", \"#99159f\", \"#9a169f\", \"#9c179e\", \"#9d189d\", \"#9e199d\", \"#a01a9c\", \"#a11b9b\", \"#a21d9a\", \"#a31e9a\", \"#a51f99\", \"#a62098\", \"#a72197\", \"#a82296\", \"#aa2395\", \"#ab2494\", \"#ac2694\", \"#ad2793\", \"#ae2892\", \"#b02991\", \"#b12a90\", \"#b22b8f\", \"#b32c8e\", \"#b42e8d\", \"#b52f8c\", \"#b6308b\", \"#b7318a\", \"#b83289\", \"#ba3388\", \"#bb3488\", \"#bc3587\", \"#bd3786\", \"#be3885\", \"#bf3984\", \"#c03a83\", \"#c13b82\", \"#c23c81\", \"#c33d80\", \"#c43e7f\", \"#c5407e\", \"#c6417d\", \"#c7427c\", \"#c8437b\", \"#c9447a\", \"#ca457a\", \"#cb4679\", \"#cc4778\", \"#cc4977\", \"#cd4a76\", \"#ce4b75\", \"#cf4c74\", \"#d04d73\", \"#d14e72\", \"#d24f71\", \"#d35171\", \"#d45270\", \"#d5536f\", \"#d5546e\", \"#d6556d\", \"#d7566c\", \"#d8576b\", \"#d9586a\", \"#da5a6a\", \"#da5b69\", \"#db5c68\", \"#dc5d67\", \"#dd5e66\", \"#de5f65\", \"#de6164\", \"#df6263\", \"#e06363\", \"#e16462\", \"#e26561\", \"#e26660\", \"#e3685f\", \"#e4695e\", \"#e56a5d\", \"#e56b5d\", \"#e66c5c\", \"#e76e5b\", \"#e76f5a\", \"#e87059\", \"#e97158\", \"#e97257\", \"#ea7457\", \"#eb7556\", \"#eb7655\", \"#ec7754\", \"#ed7953\", \"#ed7a52\", \"#ee7b51\", \"#ef7c51\", \"#ef7e50\", \"#f07f4f\", \"#f0804e\", \"#f1814d\", \"#f1834c\", \"#f2844b\", \"#f3854b\", \"#f3874a\", \"#f48849\", \"#f48948\", \"#f58b47\", \"#f58c46\", \"#f68d45\", \"#f68f44\", \"#f79044\", \"#f79143\", \"#f79342\", \"#f89441\", \"#f89540\", \"#f9973f\", \"#f9983e\", \"#f99a3e\", \"#fa9b3d\", \"#fa9c3c\", \"#fa9e3b\", \"#fb9f3a\", \"#fba139\", \"#fba238\", \"#fca338\", \"#fca537\", \"#fca636\", \"#fca835\", \"#fca934\", \"#fdab33\", \"#fdac33\", \"#fdae32\", \"#fdaf31\", \"#fdb130\", \"#fdb22f\", \"#fdb42f\", \"#fdb52e\", \"#feb72d\", \"#feb82c\", \"#feba2c\", \"#febb2b\", \"#febd2a\", \"#febe2a\", \"#fec029\", \"#fdc229\", \"#fdc328\", \"#fdc527\", \"#fdc627\", \"#fdc827\", \"#fdca26\", \"#fdcb26\", \"#fccd25\", \"#fcce25\", \"#fcd025\", \"#fcd225\", \"#fbd324\", \"#fbd524\", \"#fbd724\", \"#fad824\", \"#fada24\", \"#f9dc24\", \"#f9dd25\", \"#f8df25\", \"#f8e125\", \"#f7e225\", \"#f7e425\", \"#f6e626\", \"#f6e826\", \"#f5e926\", \"#f5eb27\", \"#f4ed27\", \"#f3ee27\", \"#f3f027\", \"#f2f227\", \"#f1f426\", \"#f1f525\", \"#f0f724\", \"#f0f921\"],\n    \"viridis\": [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"]\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/gradients.js\n// module id = 33\n// module chunks = 0","export const colorhex = {\n    \"aliceblue\": \"#f0f8ff\",\n    \"antiquewhite\": \"#faebd7\",\n    \"aqua\": \"#00ffff\",\n    \"aquamarine\": \"#7fffd4\",\n    \"azure\": \"#f0ffff\",\n    \"beige\": \"#f5f5dc\",\n    \"bisque\": \"#ffe4c4\",\n    \"black\": \"#000000\",\n    \"blanchedalmond\": \"#ffebcd\",\n    \"blue\": \"#0000ff\",\n    \"blueviolet\": \"#8a2be2\",\n    \"brown\": \"#a52a2a\",\n    \"burlywood\": \"#deb887\",\n    \"cadetblue\": \"#5f9ea0\",\n    \"chartreuse\": \"#7fff00\",\n    \"chocolate\": \"#d2691e\",\n    \"coral\": \"#ff7f50\",\n    \"cornflowerblue\": \"#6495ed\",\n    \"cornsilk\": \"#fff8dc\",\n    \"crimson\": \"#dc143c\",\n    \"cyan\": \"#00ffff\",\n    \"darkblue\": \"#00008b\",\n    \"darkcyan\": \"#008b8b\",\n    \"darkgoldenrod\": \"#b8860b\",\n    \"darkgray\": \"#a9a9a9\",\n    \"darkgreen\": \"#006400\",\n    \"darkkhaki\": \"#bdb76b\",\n    \"darkmagenta\": \"#8b008b\",\n    \"darkolivegreen\": \"#556b2f\",\n    \"darkorange\": \"#ff8c00\",\n    \"darkorchid\": \"#9932cc\",\n    \"darkred\": \"#8b0000\",\n    \"darksalmon\": \"#e9967a\",\n    \"darkseagreen\": \"#8fbc8f\",\n    \"darkslateblue\": \"#483d8b\",\n    \"darkslategray\": \"#2f4f4f\",\n    \"darkturquoise\": \"#00ced1\",\n    \"darkviolet\": \"#9400d3\",\n    \"deeppink\": \"#ff1493\",\n    \"deepskyblue\": \"#00bfff\",\n    \"dimgray\": \"#696969\",\n    \"dodgerblue\": \"#1e90ff\",\n    \"firebrick\": \"#b22222\",\n    \"floralwhite\": \"#fffaf0\",\n    \"forestgreen\": \"#228b22\",\n    \"fuchsia\": \"#ff00ff\",\n    \"gainsboro\": \"#dcdcdc\",\n    \"ghostwhite\": \"#f8f8ff\",\n    \"gold\": \"#ffd700\",\n    \"goldenrod\": \"#daa520\",\n    \"gray\": \"#808080\",\n    \"green\": \"#008000\",\n    \"greenyellow\": \"#adff2f\",\n    \"honeydew\": \"#f0fff0\",\n    \"hotpink\": \"#ff69b4\",\n    \"indianred \": \"#cd5c5c\",\n    \"indigo\": \"#4b0082\",\n    \"ivory\": \"#fffff0\",\n    \"khaki\": \"#f0e68c\",\n    \"lavender\": \"#e6e6fa\",\n    \"lavenderblush\": \"#fff0f5\",\n    \"lawngreen\": \"#7cfc00\",\n    \"lemonchiffon\": \"#fffacd\",\n    \"lightblue\": \"#add8e6\",\n    \"lightcoral\": \"#f08080\",\n    \"lightcyan\": \"#e0ffff\",\n    \"lightgoldenrodyellow\": \"#fafad2\",\n    \"lightgrey\": \"#d3d3d3\",\n    \"lightgreen\": \"#90ee90\",\n    \"lightpink\": \"#ffb6c1\",\n    \"lightsalmon\": \"#ffa07a\",\n    \"lightseagreen\": \"#20b2aa\",\n    \"lightskyblue\": \"#87cefa\",\n    \"lightslategray\": \"#778899\",\n    \"lightsteelblue\": \"#b0c4de\",\n    \"lightyellow\": \"#ffffe0\",\n    \"lime\": \"#00ff00\",\n    \"limegreen\": \"#32cd32\",\n    \"linen\": \"#faf0e6\",\n    \"magenta\": \"#ff00ff\",\n    \"maroon\": \"#800000\",\n    \"mediumaquamarine\": \"#66cdaa\",\n    \"mediumblue\": \"#0000cd\",\n    \"mediumorchid\": \"#ba55d3\",\n    \"mediumpurple\": \"#9370d8\",\n    \"mediumseagreen\": \"#3cb371\",\n    \"mediumslateblue\": \"#7b68ee\",\n    \"mediumspringgreen\": \"#00fa9a\",\n    \"mediumturquoise\": \"#48d1cc\",\n    \"mediumvioletred\": \"#c71585\",\n    \"midnightblue\": \"#191970\",\n    \"mintcream\": \"#f5fffa\",\n    \"mistyrose\": \"#ffe4e1\",\n    \"moccasin\": \"#ffe4b5\",\n    \"navajowhite\": \"#ffdead\",\n    \"navy\": \"#000080\",\n    \"oldlace\": \"#fdf5e6\",\n    \"olive\": \"#808000\",\n    \"olivedrab\": \"#6b8e23\",\n    \"orange\": \"#ffa500\",\n    \"orangered\": \"#ff4500\",\n    \"orchid\": \"#da70d6\",\n    \"palegoldenrod\": \"#eee8aa\",\n    \"palegreen\": \"#98fb98\",\n    \"paleturquoise\": \"#afeeee\",\n    \"palevioletred\": \"#d87093\",\n    \"papayawhip\": \"#ffefd5\",\n    \"peachpuff\": \"#ffdab9\",\n    \"peru\": \"#cd853f\",\n    \"pink\": \"#ffc0cb\",\n    \"plum\": \"#dda0dd\",\n    \"powderblue\": \"#b0e0e6\",\n    \"purple\": \"#800080\",\n    \"red\": \"#ff0000\",\n    \"rosybrown\": \"#bc8f8f\",\n    \"royalblue\": \"#4169e1\",\n    \"saddlebrown\": \"#8b4513\",\n    \"salmon\": \"#fa8072\",\n    \"sandybrown\": \"#f4a460\",\n    \"seagreen\": \"#2e8b57\",\n    \"seashell\": \"#fff5ee\",\n    \"sienna\": \"#a0522d\",\n    \"silver\": \"#c0c0c0\",\n    \"skyblue\": \"#87ceeb\",\n    \"slateblue\": \"#6a5acd\",\n    \"slategray\": \"#708090\",\n    \"snow\": \"#fffafa\",\n    \"springgreen\": \"#00ff7f\",\n    \"steelblue\": \"#4682b4\",\n    \"tan\": \"#d2b48c\",\n    \"teal\": \"#008080\",\n    \"thistle\": \"#d8bfd8\",\n    \"tomato\": \"#ff6347\",\n    \"turquoise\": \"#40e0d0\",\n    \"violet\": \"#ee82ee\",\n    \"wheat\": \"#f5deb3\",\n    \"white\": \"#ffffff\",\n    \"whitesmoke\": \"#f5f5f5\",\n    \"yellow\": \"#ffff00\",\n    \"yellowgreen\": \"#9acd32\"\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/colorhex.js\n// module id = 34\n// module chunks = 0","function visMap(\n    $int_fieldId,\n    $float_addrX,\n    $float_addrY,\n    $float_indexedValue0,\n    $float_indexedValue1,\n    $float_defaultValue,\n    $float_exp\n){\n    var value;\n    var d = new Vec2();\n    if(fieldId > -1) {\n        if(fieldId >= this.uIndexCount) {\n            value = this.getNonIndexedData(fieldId, addrX, addrY);\n        } else if(fieldId < this.uIndexCount) {\n            value = (fieldId == 0) ? indexedValue0 : indexedValue1;\n        }\n        if(exp != 0.0) {\n            value = pow(value, exp);\n        }\n        d = this.uVisDomains[fieldId];\n        value = (value - d.x) / (d.y - d.x);\n    } else {\n        value = defaultValue;\n    }\n    return value;\n};\n\nvar instancedXY = {};\ninstancedXY.vs  = function() {\n    var i, j, posX, posY, color, alpha, width, height, size;\n    var rgb = new Vec3();\n\n    i = (this.aDataIdx+0.5) / this.uDataDim.x;\n    j = (this.aDataIdy+0.5) / this.uDataDim.y;\n\n    if(this.uFilterFlag == 1) {\n        this.vResult = texture2D(this.fFilterResults, vec2(i, j)).a;\n    } else {\n        this.vResult = this.uVisLevel;\n    }\n\n    posX = this.visMap(this.uVisualEncodings[0], i, j, this.aDataValx, this.aDataValy, 0.0, 0.0);\n    posY = this.visMap(this.uVisualEncodings[1], i, j, this.aDataValx, this.aDataValy, 0.0,  0.0);\n    color = this.visMap(this.uVisualEncodings[2], i, j, this.aDataValx, this.aDataValy, -1.0,  0.0);\n    alpha = this.visMap(this.uVisualEncodings[3], i, j, this.aDataValx, this.aDataValy, this.uDefaultAlpha, 0.0);\n    size = this.visMap(this.uVisualEncodings[6], i, j, this.aDataValx, this.aDataValy, 1.0,  0.0);\n\n    posX = posX * 2.0 - 1.0;\n    posY = posY * 2.0 - 1.0;\n\n    rgb = this.mapColorRGB(this.uVisualEncodings[2], color);\n    gl_PointSize = size * this.uMarkSize;\n    this.vColorRGBA = vec4(rgb, alpha);\n    gl_Position = vec4(posX, posY , 0.0, 1.0);\n};\n\ninstancedXY.fs = function() {\n    var valid = new Bool();\n    valid = this.vResult <= this.uVisLevel + 0.01 && this.vResult >= this.uVisLevel - 0.01;\n    if(this.uVisShape == 1) {\n        var dist = length(gl_PointCoord.xy - vec2(0.5, 0.5));\n        if (dist > 0.5) discard;\n        var delta = 0.15;\n        var alpha = this.vColorRGBA.a - smoothstep(0.5-delta, 0.5, dist);\n        if( this.vResult <= this.uVisLevel + 0.01 && this.vResult >= this.uVisLevel - 0.01) {\n            gl_FragColor = vec4(this.vColorRGBA.rgb*alpha, alpha);\n        } else {\n            discard;\n        }\n    } else {\n        if( this.vResult <= this.uVisLevel + 0.01 && this.vResult >= this.uVisLevel - 0.01) {\n            gl_FragColor = vec4(this.vColorRGBA.rgb * this.vColorRGBA.a,  this.vColorRGBA.a);\n        } else {\n            discard;\n        }\n    }\n\n}\n\nvar interleave = {};\ninterleave.vs = function(){\n    var i, j;\n    var rgb = new Vec3();\n    var posX, posY, size, color, alpha;\n    gl_PointSize = this.uMarkSize;\n    i = (mod(this.aDataItemId, this.uDataDim.x) + 0.5) / this.uDataDim.x;\n    j = (floor(this.aDataItemId / this.uDataDim.x) + 0.5) / this.uDataDim.y;\n\n    this.vResult = this.uVisLevel;\n    if(this.uFilterFlag == 1) {\n        this.vResult = texture2D(this.fFilterResults, vec2(i, j)).a;\n    }\n    if(this.uInterleaveX == 1) {\n        posX = this.aDataFieldId.y / float(this.uFeatureCount-1);\n        posY = this.visMap(int(this.aDataFieldId.x), i, j, i, j, 1.0,  0.0);\n    } else {\n        posY = 1.0 - this.aDataFieldId.y / float(this.uFeatureCount-1);\n        posX = this.visMap(int(this.aDataFieldId.x), i, j, i, j, 1.0,  0.0);\n    }\n    color = this.visMap(this.uVisualEncodings[2], i, j, i, j, -1.0,  0.0);\n    alpha = this.visMap(this.uVisualEncodings[3], i, j, i, j, this.uDefaultAlpha, 0.0);\n\n    posX = posX * 2.0 - 1.0;\n    posY = posY * 2.0 - 1.0;\n\n    rgb = this.mapColorRGB(this.uVisualEncodings[2], color);\n    this.vColorRGBA = vec4(rgb*alpha, alpha);\n\n    gl_Position = vec4(posX, posY, 0.0, 1.0);\n}\n\ninterleave.fs = function() {\n    if(this.vResult <= this.uVisLevel + 0.01 && this.vResult >= this.uVisLevel - 0.01)\n        gl_FragColor = this.vColorRGBA;\n    else\n        discard;\n}\n\nvar polygon = {};\npolygon.vs = function(){\n    var i, j;\n    var rgb = new Vec3();\n    var posX, posY, color, alpha, width, height, size;\n    i = (mod(this.aDataItemId, this.uDataDim.x) + 0.5) / this.uDataDim.x;\n    j = (floor(this.aDataItemId / this.uDataDim.x) + 0.5) / this.uDataDim.y;\n\n    this.vResult = this.uVisLevel;\n\n    if(this.uFilterFlag == 1) {\n        this.vResult = texture2D(this.fFilterResults, vec2(i, j)).a;\n    }\n    var val0, val1;\n    val0 = this.aDataItemVal0;\n    val1 = this.aDataItemVal1;\n    posX = this.visMap(this.uVisualEncodings[0], i, j, val0, val1, 0.0, 0.0);\n    posY = this.visMap(this.uVisualEncodings[1], i, j, val0, val1, 0.0,  0.0);\n    color = this.visMap(this.uVisualEncodings[2], i, j, val0, val1, -1.0,  0.0);\n    alpha = this.visMap(this.uVisualEncodings[3], i, j,  val0, val1, this.uDefaultAlpha, 0.0);\n    width = this.visMap(this.uVisualEncodings[4], i, j,  val0, val1, this.uDefaultWidth, 0.0);\n    height = this.visMap(this.uVisualEncodings[5], i, j,  val0, val1, this.uDefaultHeight, 0.0);\n    size = this.visMap(this.uVisualEncodings[6], i, j, val0, val1, this.uMarkSize,  0.0);\n    posX = posX * (this.uFieldWidths[this.uVisualEncodings[0]] - 1.0) / this.uFieldWidths[this.uVisualEncodings[0]];\n    posY = posY * (this.uFieldWidths[this.uVisualEncodings[1]] - 1.0) / this.uFieldWidths[this.uVisualEncodings[1]];\n\n    width *= 1.0 - this.uMarkSpace.x * 2.0;\n    height *= 1.0 - this.uMarkSpace.y * 2.0;\n    posX -= this.uMarkSpace.x * width;\n    posY += this.uMarkSpace.y * height;\n\n    if(this.aVertexId == 0.0 || this.aVertexId == 3.0) {\n        posX = posX * 2.0 - 1.0;\n        posY = posY * 2.0 - 1.0;\n    } else if(this.aVertexId == 1.0) {\n        posX = posX * 2.0 - 1.0;\n        posY = (posY + height) * 2.0 - 1.0;\n    } else if(this.aVertexId == 2.0 || this.aVertexId == 5.0) {\n        posX = (posX + width) * 2.0 - 1.0;\n        posY = (posY + height) * 2.0 - 1.0;\n    } else if(this.aVertexId == 4.0) {\n        posX = (posX + width) * 2.0 - 1.0;\n        posY = posY * 2.0 - 1.0;\n    } else {\n        posX = posX * 2.0 - 1.0;\n        posY = posY * 2.0 - 1.0;\n    }\n\n    rgb = this.mapColorRGB(this.uVisualEncodings[2], color);\n    this.vColorRGBA = vec4(rgb*alpha, alpha);\n    gl_Position = vec4(posX, posY, 0.0, 1.0);\n}\n\npolygon.fs = function() {\n    if(this.vResult <= this.uVisLevel + 0.01 && this.vResult >= this.uVisLevel - 0.01)\n        gl_FragColor = this.vColorRGBA;\n    else\n        discard;\n}\n\nexport default function render(fxgl) {\n    fxgl.subroutine('visMap', 'float', visMap);\n    fxgl.program(\"instancedXY\",\n        fxgl.shader.vertex(instancedXY.vs),\n        fxgl.shader.fragment(instancedXY.fs)\n    );\n    fxgl.program(\n        \"interleave\",\n        fxgl.shader.vertex(interleave.vs),\n        fxgl.shader.fragment(interleave.fs)\n    );\n    fxgl.program(\n        \"polygon\",\n        fxgl.shader.vertex(polygon.vs),\n        fxgl.shader.fragment(polygon.fs)\n    );\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/render.js\n// module id = 35\n// module chunks = 0","const visualEncodings = ['x', 'y', 'color', 'opacity', 'width', 'height', 'size'];\n\nexport default function encode($p, vmap, colorManager) {\n    var opacity = vmap.opacity || vmap.alpha;\n    var vmapIndex = new Int32Array(visualEncodings.length);\n    visualEncodings.forEach(function(code, codeIndex){\n        vmapIndex[codeIndex] = $p.fields.indexOf(vmap[code]);\n    })\n    $p.uniform.uVisualEncodings.data = vmapIndex;\n    $p.uniform.uDefaultAlpha.data = 1.0;\n    if(vmapIndex[2] === -1) {\n        if (typeof(vmap.color) === 'string'){\n            if(vmap.color === 'auto') {\n                $p.revealDensity = true;\n                $p.uniform.uRevealMode.data = 1;\n            } else {\n                $p.uniform.uDefaultColor.data = colorManager.rgb(vmap.color);\n            }\n        } else {\n            if(typeof(vmap.size) == 'number') {\n                $p.uniform.uMarkSize = vmap.size;\n            }\n        }\n    } else {\n        if($p.categoryLookup.hasOwnProperty(vmap.color)) {\n            $p.uniform.uColorMode = 0;\n        } else {\n            $p.uniform.uColorMode = 1;\n        }\n    }\n\n    if(typeof(opacity) === 'number') {\n        $p.uniform.uDefaultAlpha.data = opacity;\n    } else if(vmapIndex[3] === -1 &&\n        typeof(opacity) == 'string' &&\n        opacity == 'auto'\n    ) {\n        $p.revealDensity = true;\n        $p.uniform.uRevealMode.data = 0;\n    }\n\n    //Check if need interleaving data attributes(e.g.,parallel coordinates)\n    if(Array.isArray(vmap.x) || Array.isArray(vmap.y)) {\n        $p.renderMode = 'interleave';\n        if(Array.isArray(vmap.x)){\n            // vmap.x = vmap.x.reverse();\n            $p.uniform.uInterleaveX = 0;\n        }\n        if(Array.isArray(vmap.y)) $p.uniform.uInterleaveX = 1;\n    } else if(vmap.mark && ['rect', 'bar'].indexOf(vmap.mark) !== -1) {\n        $p.renderMode = 'polygon';\n    }\n\n    if(vmapIndex[6] === -1 && typeof(vmap.size) == 'number') {\n        $p.uniform.uMarkSize = vmap.size;\n    }\n\n    var viewSetting = {};\n    var isRect = (['rect', 'bar'].indexOf(vmap.mark) !== -1);\n    var markSpace = [0, 0];\n    if(vmapIndex[0] > -1) {\n        var len = $p.fieldWidths[vmapIndex[0]],\n            ext = $p.fieldDomains[vmapIndex[0]];\n        if($p.categoryLookup.hasOwnProperty(vmap.x)){\n            viewSetting.scaleX = 'categorical';\n             viewSetting.domainX = new Array(len).fill(0).map(\n                 (d,i)=>$p.categoryLookup[vmap.x][i]\n             );\n         } else if (isRect) {\n             viewSetting.scaleX = 'ordinal';\n             viewSetting.domainX = new Array(len).fill(0).map((d,i)=>ext[0] + i);\n         }\n         markSpace[0] = 0.02;\n    }\n    if(vmapIndex[1] > -1) {\n        var len = $p.fieldWidths[vmapIndex[1]],\n            ext = $p.fieldDomains[vmapIndex[1]];\n\n        if($p.categoryLookup.hasOwnProperty(vmap.y)){\n             viewSetting.scaleY = 'categorical';\n             viewSetting.domainY = new Array(len).fill(0).map(\n                 (d,i)=>$p.categoryLookup[vmap.y][i]\n             ).reverse();\n        } else if (isRect) {\n            viewSetting.scaleY = 'ordinal';\n            viewSetting.domainY = new Array(len).fill(0).map((d,i)=>ext[0] + i).reverse();\n        }\n        markSpace[1] = 0.02;\n    }\n\n    if(vmapIndex[0] > -1 && vmapIndex[1] > -1) {\n        markSpace = [0, 0];\n    }\n\n    $p.uniform.uMarkSpace.data = markSpace;\n\n    if($p.intervals.hasOwnProperty(vmap.x) || $p.intervals.hasOwnProperty(vmap.y)) {\n        var histDim = vmap.x || vmap.y,\n            histMin = $p.intervals[histDim].min,\n            histMax = $p.intervals[histDim].max,\n            histIntv = $p.intervals[histDim].interval,\n            histBin = (histMax - histMin) / histIntv;\n\n        // viewSetting.fields = $p.fields;\n        viewSetting.isHistogram = true;\n        // viewSetting.domain = {};\n        viewSetting.domainX = new Array(histBin).fill(histMin).map(function(h, i) {return h + i*histIntv});\n    }\n\n    if(!$p._update) {\n        if(!vmap.width && vmap.x) {\n            $p.uniform.uDefaultWidth.data = 1.0 / ($p.fieldWidths[$p.fields.indexOf(vmap.x)] );\n        } else if(vmapIndex[4] === -1 && typeof(vmap.width) == 'number') {\n            $p.uniform.uDefaultWidth.data = vmap.width / width;\n        }\n\n        if(!vmap.height && vmap.y) {\n            $p.uniform.uDefaultHeight.data = 1.0 / ($p.fieldWidths[$p.fields.indexOf(vmap.y)] );\n        } else if(vmapIndex[5] === -1 && typeof(vmap.width) == 'number') {\n            $p.uniform.uDefaultHeight.data = vmap.height / height;\n        }\n    }\n    return viewSetting;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/encode.js\n// module id = 36\n// module chunks = 0","export default function brush(arg){\n\n    var option = arg || {},\n        container = option.container || this.svg[0],\n        width = option.width || this.width,\n        height = option.height || this.height,\n        x = function(s) {return s},\n        y = function(s) {return s},\n        base = option.base || null,\n        selectX = option.x || false,\n        selectY = option.y || false,\n        border = option.border || \"#FFF\",\n        color = option.color || \"#111\",\n        brush = option.brush || function() {},\n        brushstart = option.brushstart || function() {},\n        brushend = option.brushend || function() {};\n\n    if(typeof(selectX) === \"function\") {\n        x = selectX;\n        selectX = true;\n    }\n    if(typeof(selectY) === \"function\") {\n        y = selectY;\n        selectY = true;\n    }\n    if(base === null){\n        base = container.append(\"g\").attr(\"class\", \"selector\");\n    } else {\n        base = container;\n    };\n\n    base.append(\"rect\")\n        .attr(\"x\", 0)\n        .attr(\"y\", 0)\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .attr(\"fill-opacity\", 0)\n        .attr(\"stroke\", \"none\")\n        .css(\"cursor\", \"crosshair\");\n\n    var selector = base.append(\"rect\")\n        .attr(\"x\", 0)\n        .attr(\"y\", 0)\n        .attr(\"width\", 0)\n        .attr(\"height\", 0)\n        .attr(\"fill-opacity\", 0.1)\n        .css(\"fill\", color)\n        .css(\"stroke\", border)\n        .css(\"cursor\", \"move\");\n\n    var sx, sy,\n        dx, dy,\n        bx, by,\n        selection = {},\n        intStart = false,\n        drag = false;\n\n    base.svg.addEventListener(\"mousedown\", function(evt){\n        evt.preventDefault();\n        brushstart.call(this);\n        intStart = true;\n        sx = evt.clientX;\n        sy = evt.clientY;\n\n        var sp = selector.svg.getBoundingClientRect();\n        var box = base.svg.getBoundingClientRect();\n        var x0, y0, nw, nh;\n\n        if(sx>sp.left && sy>sp.top && sx<sp.left+sp.width && sy<sp.top+sp.height) {\n            drag = true;\n            bx = sp.left;\n            by = sp.top;\n        }\n\n        if(!drag){\n            x0 = selectX ? sx - box.left : 0;\n            y0 = selectY ? sy - box.top : 0;\n            selector.attr(\"x\", x0)\n                .attr(\"y\", y0)\n                .attr(\"width\", 0);\n        }\n\n        ondrag = function(evt){\n            if(intStart){\n                dx = evt.clientX - sx;\n                dy = evt.clientY - sy;\n                var selectorBox = selector.svg.getBoundingClientRect();\n                if(drag){\n\n                    var nx = bx + dx-box.left,\n                        ny = by + dy-box.top;\n\n                    if(bx+dx < box.left) nx = 0;\n                    if(bx+dx+selectorBox.width > box.right) nx = width - selectorBox.width ;\n                    if(by+dy < box.top) ny = 0;\n                    if(by+dy+selectorBox.height > box.bottom) ny = height - selectorBox.height;\n                    selector.attr(\"x\", nx).attr(\"y\", ny);\n                } else {\n                    if(evt.clientX < box.left) dx = box.left - sx;\n                    if(evt.clientX > box.right) dx = box.right - sx;\n                    if(evt.clientY > box.bottom) dy = box.bottom - sy;\n                    if(evt.clientY < box.top) dy = box.top - sy;\n\n                    x0 = selectX ? sx + dx - box.left: 0;\n                    y0 = selectY ? sy + dy - box.top : 0;\n                    nw = selectX ? Math.abs(dx) : width;\n                    nh = selectY ? Math.abs(dy) : height;\n\n                    if(dx<0 && dy>=0) selector.attr(\"x\", x0);\n                    if(dy<0 && dx>=0) selector.attr(\"y\", y0);\n                    if(dx<0 && dy<0) selector.attr(\"x\", x0).attr(\"y\", y0);\n                    selector.attr(\"width\", nw).attr(\"height\", nh);\n                }\n                if(selectX) {\n                    selection.x = [ x(selectorBox.left - box.left ), x(selectorBox.right - box.left )];\n                }\n                if(selectY) {\n                    selection.y = [y(selectorBox.top - box.top), y(selectorBox.bottom - box.top)];\n                }\n                brush.call(this, selection);\n            }\n        };\n\n        window.addEventListener(\"mousemove\", ondrag, false);\n        window.addEventListener(\"mouseup\", function(evt){\n            if(intStart){\n                ondrag(evt);\n                intStart = false;\n                if(drag){\n                    drag = false;\n                }\n            }\n            brushend.call(this, selection);\n            window.removeEventListener(\"mousemove\", ondrag, false);\n        }, false);\n    });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/metavis/brush.js\n// module id = 37\n// module chunks = 0","import Svg from './svg';\nimport chart from './chart';\n\nfunction assign(object, source) {\n    Object.keys(source).forEach(function(key) {\n        object[key] = source[key];\n    });\n}\nvar defaultProperties = {\n    width: 400,\n    height: 300,\n    padding: {left: 0, right: 0, top: 0, bottom: 0},\n}\n\nexport default function layout(arg){\n    \"use strict\";\n\n    /* Private */\n    var viz = this,\n        option = arg || {},\n        container = option.container || document.body,\n        style = option.style || null,\n        layers = [];\n\n    this.width = container.clientWidth || 400;\n    this.height = container.clientHeight || 300;\n\n    if(typeof container == 'string') container = document.getElementById(container);\n    assign(viz, defaultProperties);\n    assign(viz, option);\n\n    this.vmap = option.vmap;\n\n    this.width -= (this.padding.left + this.padding.right);\n    this.height -= (this.padding.top + this.padding.bottom);\n\n\n    /* Public */\n    this.data = option.data || [];\n    this.div = document.createElement(\"div\");\n    if(style !== null) {\n        Object.keys(style).forEach(function(prop){\n            viz.div.style[prop] = style[prop];\n        })\n    }\n\n    this.init = function(){\n        // container = (containerId == \"body\") ? document.body : document.getElementById(containerId);\n\n        this.div.className = option.className || \"p6-viz\";\n        this.div.style.position = 'relative';\n        this.resize(\n            this.width + this.padding.left + this.padding.right,\n            this.height + this.padding.top + this.padding.bottom\n        );\n\n        if(option.style) this.css(option.style);\n\n        container.appendChild(this.div);\n        this.viz();\n        return viz;\n    };\n\n    this.createSVG = function(arg) {\n        var arg = arg || {},\n            width = arg.width || this.width,\n            height = arg.height || this.height,\n            padding = arg.padding || this.padding;\n\n        return new Svg({\n            width: width,\n            height: height,\n            padding: padding,\n            style: {position: 'absolute'}\n        });\n    }\n\n    var canvas = option.canvas,\n        svg = this.createSVG(),\n        vmap = option.vmap,\n        chartPadding = this.padding || {left: 0, right: 0, top: 0, bottom: 0},\n        domain = option.domain || {x: [0, 1000], y: [0, 1]},\n        scales = option.scales || {x: 'linear', y: 'linear'};\n\n    var backSVG = this.createSVG(),\n        frontSVG = this.createSVG();\n\n    this.set = function(props) {\n        assign(viz, props);\n    };\n\n    this.addProperty = function(obj, prop) {\n        assign(obj, prop);\n        return obj;\n    }\n\n    this.viz = function() {\n        viz.div.appendChild(backSVG.svg);\n        viz.div.appendChild(canvas);\n        viz.div.appendChild(frontSVG.svg);\n        return viz;\n    };\n\n    this.render = this.viz;\n\n    this.css = function(style){\n        for(var key in style){\n            this.div.style[key] = style[key];\n        }\n        return this;\n    };\n\n    this.resize = function(w,h){\n        this.div.style.width = w + \"px\";\n        this.div.style.height = h + \"px\";\n    };\n\n    this.destroy = function() {\n        this._super.destroy();\n        container.removeChild(this.div);\n        div = null;\n    };\n\n    this.hide = function() {\n        this.div.style.display = 'none';\n    }\n\n    this.show = function() {\n        this.div.style.display = 'block';\n    }\n\n    this.innerWidth = function() {\n        return this.width;\n    }\n\n    this.innerHeight = function() {\n        return this.height;\n    }\n\n    this.addChart = function(options) {\n        return chart(frontSVG, options)\n    };\n\n    this.exportImage = function(beforeExport) {\n        var imageCanvas = document.createElement(\"canvas\");\n        imageCanvas.width = this.width;\n        imageCanvas.height = this.height;\n        return new Promise(function(resolve, reject) {\n\n            var ctx = imageCanvas.getContext(\"2d\");\n            var svgString = new XMLSerializer().serializeToString(frontSVG.svg);\n\n            var DOMURL = self.URL || self.webkitURL || self;\n            var svgBlob = new Blob([svgString], {type: \"image/svg+xml;charset=utf-8\"});\n            var svgURL = DOMURL.createObjectURL(svgBlob);\n\n            var canvasLayer = new Image();\n            var svgLayer = new Image();\n            canvasLayer.onload = function() {\n                ctx.drawImage(canvasLayer, 0, 0);\n                svgLayer.src = svgURL;\n                svgLayer.onload = function() {\n                    ctx.drawImage(svgLayer, 0, 0);\n                    var png = imageCanvas.toDataURL(\"image/png\");\n                    DOMURL.revokeObjectURL(png);\n                    resolve(png);\n                };\n            };\n\n            canvasLayer.onerror = function() {\n                reject(Error(\"Canvas Output Error!\"));\n            }\n\n            svgLayer.onerror = function() {\n                reject(Error(\"SVG Output Error!\"));\n            }\n            beforeExport();\n            canvasLayer.src = canvas.toDataURL(\"image/png\");\n        });\n\n    }\n\n    return viz.init();\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/metavis/layout.js\n// module id = 38\n// module chunks = 0","import axis from './axis';\nimport format from './format';\nimport scale from './scale';\nimport legend from './legend';\n\nexport default function chart(svg, arg) {\n    var options = arg || {},\n        plot = svg.append('g'),\n        width = options.width,\n        height = options.height,\n        top = options.top || 0,\n        left = options.left || 0,\n        vmap = options.vmap || {},\n        isHistogram = options.isHistogram || options.hist || false,\n        features = options.fields || [],\n        domain = options.domain,\n        categories = options.categories,\n        labels = plot.append('g'),\n        onclick = options.onclick || null,\n        onhover = options.onhover || null,\n        showLegend = options.legend || true,\n        tickOffset = options.axisOffset || [0, 0],\n        padding = options.padding || {left: 0, right: 0, top: 0, bottom: 0},\n        marks = [],\n        colors = options.colors;\n\n    var scaleX = options.scaleX || 'linear',\n        domainX = options.domainX || domain[vmap.x] || domain[vmap.width],\n        scaleY = options.scaleY || 'linear',\n        domainY = options.domainY || domain[vmap.y] || domain[vmap.height];\n\n    width -= padding.left + padding.right;\n    height -= padding.top + padding.bottom;\n\n    var xAxisOption = {\n        container: plot,\n        dim: \"x\",\n        width: width,\n        height: height,\n        domain: domainX,\n        scale:  scaleX,\n        align: \"bottom\",\n        // ticks: 5,\n        // grid: 1,\n        format: format(\".3s\"),\n    };\n\n    var yAxisOption = {\n        container: plot,\n        dim: \"y\",\n        domain: domainY,\n        scale: scaleY,\n        width: width,\n        height: height,\n        align: \"left\",\n        // labelPos: {x: -5, y: -5},\n        // grid: 1,\n        format: format(\".3s\"),\n    };\n\n    if(showLegend && features.indexOf(vmap.color) !== -1){\n        legend({\n            container: plot,\n            width: 20,\n            height: 180,\n            dim: \"y\",\n            domain: domain[vmap.color],\n            pos: [width + padding.right/2, 0],\n            colors: colors\n        });\n    }\n\n    if(scaleX == 'ordinal' || scaleX == 'categorical') {\n        xAxisOption.ticks = domainX.length;\n        while(width / xAxisOption.ticks < 20) {\n            xAxisOption.ticks *= 0.5;\n        }\n        var maxStrLength = Math.max.apply(null, domainX.map(\n            function(d){ return (typeof(d) == 'string') ? d.toString().length : 1; })\n        );\n        if(maxStrLength > 10) {\n            xAxisOption.labelAngle = -30;\n            xAxisOption.tickLabelAlign = 'end';\n            xAxisOption.labelPos = {x: 0, y: -10};\n        }\n    }\n\n    if(scaleY == 'ordinal' || scaleY == 'categorical') {\n        yAxisOption.ticks = domainY.length;\n        while(width / yAxisOption.ticks < 20) {\n            yAxisOption.ticks *= 0.5;\n        }\n    }\n\n    var x, y, xAxes = [], yAxes = [];\n\n    // For parallel coordinates\n    if(Array.isArray(vmap.x)) {\n        var axisDist = height / (vmap.x.length-1);\n\n        vmap.x.forEach(function(d, i) {\n            xAxisOption.position = i * axisDist + 1;\n            xAxisOption.domain = domain[d];\n            if(categories.hasOwnProperty(d)){\n                xAxisOption.scale = 'ordinal';\n                xAxisOption.tickAlign = 'outer';\n                xAxisOption.domain = categories[d].reverse();\n            }\n            var labelOffset = 20;\n            if(i === 0) {\n                xAxisOption.tickPosition = [0, -5];\n                xAxisOption.labelPos = {x: 0, y: 2};\n                labelOffset = 35;\n            } else {\n                xAxisOption.tickPosition = null;\n                xAxisOption.labelPos = null;\n            }\n            x = axis(xAxisOption);\n            xAxes[i] = x;\n\n            labels\n            .append(\"text\")\n              .attr(\"x\", 5 )\n              .attr(\"y\", i * axisDist - labelOffset)\n              .attr(\"dy\", \"1em\")\n              .css(\"text-anchor\", \"middle\")\n              .css(\"font-size\", \"1em\")\n              .text(d);\n        });\n    }\n\n    if(Array.isArray(vmap.y)) {\n        var axisDist = width / (vmap.y.length-1);\n\n        vmap.y.forEach(function(d, i) {\n            yAxisOption.position = i * axisDist;\n            yAxisOption.domain = domain[d];\n            if(categories.hasOwnProperty(d)){\n                yAxisOption.scale = 'ordinal';\n                yAxisOption.tickAlign = 'outer';\n                yAxisOption.domain = categories[d].reverse();\n            }\n            if(i == vmap.y.length-1) {\n                yAxisOption.tickPosition = [5, 0];\n                yAxisOption.tickLabelAlign = \"start\";\n                yAxisOption.labelPos = {x: 8, y: -5};\n\n            }\n            y = axis(yAxisOption);\n            yAxes[i] = y;\n\n            labels.append(\"text\")\n              .attr(\"y\", -padding.top + 10)\n              .attr(\"x\", i * axisDist)\n              .attr(\"dy\", \"1em\")\n              .css(\"text-anchor\", \"middle\")\n              .css(\"font-size\", \"1em\")\n              .text(d);\n        });\n    }\n\n    if(isHistogram) {\n        xAxisOption.tickPosition = [width / domainX.length /2, 0];\n        xAxisOption.scale = \"ordinal\";\n        xAxisOption.domain = domainX;\n        xAxisOption.ticks = domainX.length;\n    }\n\n    if((vmap.x || vmap.width) && !Array.isArray(vmap.x)) x = axis(xAxisOption);\n    if((vmap.y || vmap.height) && !Array.isArray(vmap.y)) y = axis(yAxisOption);\n\n    if((vmap.hasOwnProperty('x') || vmap.hasOwnProperty('width')) && !Array.isArray(vmap.x)) {\n        var xAxisTitle = vmap.x || vmap.width;\n        // xAxisTitle = xAxisTitle.replace(/_/g, ' ');\n        // xAxisOption.grid = 1;\n        labels.append(\"g\")\n          .append(\"text\")\n            .attr(\"x\", width/2)\n            .attr(\"y\", height + padding.bottom/2 )\n            .attr(\"dy\", \"1em\")\n            .css(\"text-anchor\", \"middle\")\n            .css(\"font-size\", \"1.0em\")\n            .css(\"font-weight\", \"bold\")\n            .css(\" text-transform\", \"capitalize\")\n            .text(xAxisTitle);\n\n    }\n    if((vmap.hasOwnProperty('y') || vmap.hasOwnProperty('height')) && !Array.isArray(vmap.y)) {\n        var yAxisTitle = vmap.y || vmap.height;\n        // yAxisTitle = yAxisTitle.replace(/_/g, ' ');\n        // yAxisOption.grid = 1;\n        if(!Array.isArray(vmap.y)) {\n            labels.append(\"g\")\n              .append(\"text\")\n                .attr(\"transform\", \"rotate(-90)\")\n                .attr(\"y\", -padding.left/1.25 )\n                .attr(\"x\", -height/2 )\n                .attr(\"dy\", \"1em\")\n                .css(\"text-anchor\", \"middle\")\n                .css(\"font-size\", \"1.0em\")\n                .css(\"font-weight\", \"bold\")\n                .css(\" text-transform\", \"capitalize\")\n                .text(yAxisTitle);\n        }\n    }\n    // plot.append(\"line\")\n    //     .attr('x1', 0)\n    //     .attr('x2', width)\n    //     .attr('y1', 0)\n    //     .attr('y2', 0)\n    //     .css('stroke', '#000')\n    // plot.append(\"line\")\n    //     .attr('x1', width)\n    //     .attr('x2', width)\n    //     .attr('y1', 0)\n    //     .attr('y2', height)\n    //     .css('stroke', '#000')\n        // .css('stroke-opacity', 0.5)\n\n    plot.translate(padding.left+left, padding.top+top);\n\n    var chartLayer = {};\n\n    chartLayer.update =  function(spec) {\n        var data = spec.data || [];\n\n        if(data.length) {\n            data.forEach(function(d, i){\n                var barHeight = isFinite(y(d[vmap.y])) ? y(d[vmap.y]) : height;\n                if(hMarks[i]) {\n                    hMarks[i].Attr({\n                        y: barHeight,\n                        height: height - barHeight,\n                        fill: \"orange\"\n                    });\n                }\n            })\n        } else {\n            hMarks.forEach(function(h, i){\n                h.Attr({ y: 0, height: 0 });\n            })\n        }\n    }\n\n    chartLayer.removeAxis = function() {\n        x.remove();\n        y.remove();\n        if(yAxes.length) {\n            yAxes.forEach(function(yp) {\n                yp.remove();\n            })\n        }\n    }\n\n    chartLayer.svg = plot;\n    chartLayer.x = Array.isArray(vmap.x) ? xAxes : x;\n    chartLayer.y = Array.isArray(vmap.y) ? yAxes : y;\n\n    return chartLayer;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/metavis/chart.js\n// module id = 39\n// module chunks = 0","function _reduce(array, opt) {\n    var i,\n        len = array.length,\n        fn,\n        result;\n\n    if (!len) return 0;\n\n    switch (opt) {\n        case \"max\":\n            result = array.reduce(function(a, b) {\n                return (a > b) ? a : b;\n            });\n            break;\n        case \"min\":\n            result = array.reduce(function(a, b) {\n                return (a < b) ? a : b;\n            });\n            break;\n        case \"and\":\n        case \"&\":\n            result = array.reduce(function(a, b) {\n                return a & b;\n            });\n            break;\n        case \"or\":\n        case \"|\":\n            result = array.reduce(function(a, b) {\n                return a | b;\n            });\n            break;\n        case \"mult\":\n        case \"*\":\n            result = array.reduce(function(a, b) {\n                return a * b;\n            });\n            break;\n        default: // \"sum\" or \"+\"\n            result = array.reduce(function(a, b) {\n                return a + b;\n            });\n            break;\n    }\n\n    return result;\n}\n\nexport function reduce(opt) {\n    return function(array) {\n        var a = (array instanceof Array) ? array : Array.apply(null, arguments);\n        return _reduce(a, opt);\n    };\n};\n\nexport function avg(array) {\n    return _reduce(array, \"+\") / array.length;\n    // return array.reduce(function(a,b){ return 0.5 * (a + b)});\n};\n\nexport function normalize(array) {\n    var max = _reduce(array, \"max\"),\n        min = _reduce(array, \"min\"),\n        range = max - min;\n\n    return array.map(function(a) {\n        return (a - min) / range;\n    });\n}\n\nexport function seq(start, end, intv) {\n    var interval = intv || 1,\n        array = [];\n\n    for (var i = start; i <= end; i += interval)\n        array.push(i);\n\n    return array;\n};\n\n// [\"max\", \"min\", \"mult\", \"and\", \"or\"].forEach(function(f) {\n//     array[f] = array.reduce(f);\n// });\n\n// export sum = array.reduce(\"+\");\n\nexport function scan(a) {\n    var pfsum = [],\n        accum = 0;\n\n    for (var i = 0; i < a.length; i++) {\n        accum += a[i];\n        pfsum.push(accum);\n    }\n\n    return pfsum;\n};\n\nexport function iscan(a) {\n    return array.scan([0].concat(a));\n};\n\nexport function diff(a, b) {\n    var difference = [];\n    a.forEach(function(d) {\n        if (b.indexOf(d) === -1) {\n            difference.push(d);\n        }\n    });\n    return difference;\n};\n\nexport function intersect(a, b) {\n    var t;\n    if (b.length > a.length) t = b, b = a, a = t; // indexOf to loop over shorter\n    return a.filter(function(e) {\n        if (b.indexOf(e) !== -1) return true;\n    });\n};\n\nexport function unique(a) {\n    return a.reduce(function(b, c) {\n        if (b.indexOf(c) < 0) b.push(c);\n        return b;\n    }, []);\n};\n\nexport function lcm(A) {\n    var n = A.length,\n        a = Math.abs(A[0]);\n    for (var i = 1; i < n; i++) {\n        var b = Math.abs(A[i]),\n            c = a;\n        while (a && b) {\n            (a > b) ? a %= b: b %= a;\n        }\n        a = Math.abs(c * A[i]) / (a + b);\n    }\n    return a;\n};\n\nexport function stats(array) {\n    return {\n        max: _reduce(array, \"max\"),\n        min: _reduce(array, \"min\"),\n        avg: array.avg(array)\n    };\n};\n\nexport function histogram(array, numBin, _max, _min) {\n    var l = array.length,\n        min = (typeof(_min) == 'number') ? _min : _reduce(array, \"min\"),\n        max = (typeof(_max) == 'number') ? _max : _reduce(array, \"max\"),\n        range = max - min,\n        interval = range / numBin,\n        bins = [],\n        // ids = [],\n        hg = new Array(numBin + 1).fill(0);\n\n    for (var b = 0; b < numBin; b++) {\n        bins.push([min + range * (b / (numBin)), min + range * (b + 1) / (numBin)]);\n        // ids[b] = [];\n    }\n\n    // ids[numBin] = [];\n\n    for (var i = 0; i < l; i++) {\n        binID = Math.floor((array[i] - min) / range * (numBin));\n        hg[binID]++;\n        // ids[binID].push(i);\n    };\n\n    hg[numBin - 1] += hg[numBin];\n    // ids[numBin-1] = ids[numBin-1].concat(ids.pop());\n    return {\n        bins: bins,\n        counts: hg.slice(0, numBin),\n        // ids: ids\n    };\n}\n\nexport function variance(rowArray) {\n    var m = _reduce(rowArray, \"+\") / rowArray.length,\n        va = rowArray.map(function(a) {\n            return Math.pow(a - m, 2)\n        });\n\n    return _reduce(va, \"+\") / (rowArray.length - 1);\n}\n\nexport function std(rowArray) {\n    return Math.sqrt(array.var(rowArray));\n}\n\nexport function vectorAdd(a, b) {\n    var c = [];\n    a.forEach(function(v, i) {\n        c[i] = v + b[i];\n    });\n\n    return c;\n}\n\nexport function vectorSum(vectors) {\n    var result = vectors[0],\n        numberOfVectors = vectors.length;\n\n    for (var i = 1; i < numberOfVectors; i++) {\n        result = array.vectorAdd(result, vectors[i]);\n    }\n\n    return result;\n}\n\nfunction _vectorAvg(a, b) {\n    var c = [];\n    a.forEach(function(v, i) {\n        c[i] = (v + b[i]) * 0.5;\n    });\n\n    return c;\n}\n\nexport function vectorAvg(vectors) {\n    var result = vectors[0],\n        numberOfVectors = vectors.length;\n\n    for (var i = 1; i < numberOfVectors; i++) {\n        result = _vectorAvg(result, vectors[i]);\n    }\n\n    return result;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/arrays.js\n// module id = 40\n// module chunks = 0","import Svg from './svg';\nimport Axis from './axis';\nimport printformat from './format';\n\nconst defaultColors = ['white', 'steelblue'];\nconst defaultSize = 20;\nvar gradID = 0;\n\nexport default function color(arg){\n    var gradientID = gradID++;\n\n    var option = arg || {},\n        container = option.container || null,\n        width = option.width || null,\n        height = option.height || null,\n        pos = option.pos ||[0, 0],\n        dim = option.dim || 'x',\n        padding = option.padding || {left: 0, right: 0, top: 0, bottom: 0},\n        vmap = option.vmap || {},\n        label = option.label || false,\n        colors = option.colors || defaultColors,\n        domain = option.domain || ['min', 'max'],\n        format = option.format || printformat('.3s');\n\n\n    if(colors.length < 2) colors = defaultColors;\n    width -= padding.left + padding.right;\n    height -= padding.top + padding.bottom;\n\n    var legend = (container === null)\n        ? new Svg({width: width, height: height, padding: padding})\n        : container.append('g');\n\n    var gradDirection;\n    if(dim == 'x') {\n        gradDirection = {x1: 0, x2: 1, y1: 0, y2: 0};\n        if(height === null) height = defaultSize;\n    } else {\n        gradDirection = {x1: 0, x2: 0, y1: 0, y2: 1};\n        if(width === null) width = defaultSize;\n    }\n\n    function linearGradient(colors) {\n        var gradient = legend.append('defs')\n            .append('linearGradient')\n                .attr('id', 'gradlegend'+gradientID)\n                .attr(gradDirection);\n\n        colors.forEach(function(c, i){\n            gradient.append('stop')\n                .attr('offset', i / (colors.length-1) )\n                .attr('stop-color', colors[colors.length-i-1]);\n        });\n        return gradient;\n    }\n\n    var grad = linearGradient(colors);\n\n    var rect = legend.append('g');\n\n    var colorScale = rect.append('rect')\n        .attr('width', width-padding.left)\n        .attr('height', height)\n        .style('fill','url(#gradlegend' + gradientID + ')');\n\n    var domainLabel = legend.append('text');\n    if(label) {\n        label.append('text')\n            .attr('x', pos[0] - 5)\n            .attr('y', pos[1] + height/2 + 5)\n            .style('fill', '#222')\n            .style('text-anchor', 'end')\n            .text(printformat('2s')(domain[0]));\n\n        legend.append('text')\n            .attr('x', pos[0] + width - padding.left + 5)\n            .attr('y', pos[1] + height/2 + 5)\n            .style('fill', '#222')\n            .style('text-anchor', 'begin')\n            // .style('font-size', '.9em')\n            .text(printformat('2s')(domain[1]));\n    }\n\n    if(option.title) {\n        legend.append('g')\n          .append('text')\n            .attr('y', pos[1] - padding.top)\n            .attr('x', pos[0] + width/2)\n            .attr('dy', '1em')\n            .style('text-anchor', 'middle')\n            .text(option.title);\n    }\n\n    if(dim == 'x') {\n        new Axis({\n            dim: 'x',\n            domain: domain,\n            container: legend,\n            align: 'bottom',\n            ticks: Math.floor(width / 30),\n            height: height,\n            width: width,\n            labelPos: {x: 0, y: -20},\n            format: format,\n        });\n    } else {\n        new Axis({\n            dim: 'y',\n            domain: domain,\n            container: legend,\n            align: 'right',\n            ticks: Math.floor(height / 30),\n            height: height,\n            width: width,\n            labelPos: {x: 0, y: -20},\n            format: format,\n        });\n    }\n\n\n    // legend.appendChild(xAxis);\n\n    legend.translate(pos[0]+padding.left, pos[1]+padding.top);\n\n    // legend.update = function(newDomain, newColors) {\n    //\n    //     legend.removeChild(xAxis);\n    //     xAxis = new Axis({\n    //         dim: 'x',\n    //         domain: newDomain,\n    //         container: legend,\n    //         align: 'bottom',\n    //         ticks: 4,\n    //         // tickInterval: 10000000,\n    //         labelPos: {x: -5, y: -20},\n    //          padding: padding,\n    //         width: width-padding.left,\n    //         format: format,\n    //     }).show();\n    //\n    //     if(typeof(newColors) != 'undefined') {\n    //         grad.remove();\n    //         grad = linearGradient(newColors);\n    //         colorScale.css('fill','url(#gradlegend' + gradientID + ')');\n    //\n    //     }\n    //     // legend.appendChild(xAxis);\n    //\n    //     return legend;\n    // }\n\n    return legend;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/metavis/legend.js\n// module id = 41\n// module chunks = 0","import * as ctypes from './ctypes';\r\nexport default function ColumnStore(arg){\r\n    var cstore   = (this instanceof ColumnStore) ? this : {},\r\n        options = arg || {},\r\n        columns  = [],                  // column-based binary data\r\n        size     = options.size  || 0,   // max size\r\n        count    = options.count || 0,   // number of entries stored\r\n        types    = options.types || [],  // types of the columns\r\n        attributes = options.attributes || options.keys || options.names || [],  // column attributes\r\n        struct   = options.struct|| options.schema || {},\r\n        strHashes     = options.strHashes  || {},  // content access memory\r\n        strLists     = options.strLists  || {},  // table lookaside buffer\r\n        colStats = {},\r\n        colAlloc = {},\r\n        colRead  = {},                  // functions for reading values\r\n        skip     = options.skip  || 0;\r\n\r\n    if(options.struct) initStruct(options.struct);\r\n\r\n    function initCStore() {\r\n        if(size && types.length === attributes.length && types.length > 0) {\r\n            attributes.forEach(function(c, i){\r\n                configureColumn(i);\r\n                columns[i] = new colAlloc[c](size);\r\n                if(!columns.hasOwnProperty(c))\r\n                    Object.defineProperty(columns, c, {\r\n                        get: function() { return columns[i]; }\r\n                    });\r\n            });\r\n            columns.attributes = attributes;\r\n            columns.keys = attributes;\r\n            columns.types = types;\r\n            columns.struct = struct;\r\n            columns.strLists = strLists;\r\n            columns.strHashes = strHashes;\r\n            columns.size = size;\r\n            columns.get = function(c) {\r\n                var index = attributes.indexOf(c);\r\n                if(index < 0 ) throw new Error(\"Error: No column named \" + c);\r\n                return columns[index];\r\n            }\r\n        } \r\n        return cstore;\r\n    }\r\n\r\n    function initStruct(s) {\r\n        struct = s;\r\n        if(Array.isArray(struct)) {\r\n            struct.forEach(function(s){\r\n                attributes.push(s.name);\r\n                types.push(s.type);\r\n            })\r\n        } else {\r\n            for(var k in struct){\r\n                attributes.push(k);\r\n                types.push(struct[k]);\r\n            }\r\n        }\r\n        return struct;\r\n    }\r\n\r\n    function configureColumn(cid) {\r\n        if(typeof(cid) == \"string\") cid = attributes.indexOf(cid);\r\n        var f = attributes[cid];\r\n        colAlloc[f] = ctypes[types[cid]];\r\n\r\n        if(colAlloc[f] === ctypes.string){\r\n            strLists[f] = [];\r\n            strHashes[f] = {};\r\n            colRead[f] = function(value) {\r\n                if(!strHashes[f].hasOwnProperty(value)){\r\n                    strHashes[f][value] = strLists[f].length;\r\n                    strLists[f].push(value);\r\n                }\r\n                return strHashes[f][value];\r\n            };\r\n        } else if(\r\n            colAlloc[f] === ctypes.int ||\r\n            colAlloc[f] === ctypes.short ||\r\n            colAlloc[f] === ctypes.integer\r\n        ) {\r\n            colRead[f] = function(value) {  return parseInt(value) || 0; };\r\n        } else if(\r\n            colAlloc[f] === ctypes.float ||\r\n            colAlloc[f] === ctypes.double ||\r\n            colAlloc[f] === ctypes.numeric\r\n        ){\r\n            colRead[f] = function(value) {  return parseFloat(value) || 0.0; };\r\n        } else if(\r\n                colAlloc[f] === ctypes.time ||\r\n                colAlloc[f] === ctypes.temporal\r\n        ) {\r\n            colRead[f] = function(value) {  return parseFloat(value) || 0.0; };\r\n        } else {\r\n            throw new Error(\"Invalid data type for TypedArray data!\")\r\n        }\r\n    }\r\n\r\n    cstore.addRows = function(rowArray) {\r\n        if(count === 0 && skip > 0) {\r\n            for(var j = 0; j<skip; j++)\r\n                rowArray.shift();\r\n        }\r\n        rowArray.forEach(function(row, i){\r\n            row.forEach(function(v,j){\r\n                columns[j][count] = colRead[attributes[j]](v);\r\n            });\r\n            count++;\r\n        });\r\n        return count;\r\n    }\r\n\r\n    cstore.addObjects = function(objArray) {\r\n        if(count === 0 && skip > 0) {\r\n            for(var j = 0; j<skip; j++)\r\n                objArray.shift();\r\n        }\r\n        objArray.forEach(function(obj, i){\r\n            Object.keys(obj).forEach(function(v,j){\r\n                columns[j][count] = colRead[attributes[j]](obj[v]);\r\n            });\r\n            count++;\r\n        });\r\n        return count;\r\n    }\r\n\r\n\r\n    cstore.addColumn = function(arg) {\r\n        var props = arg || {},\r\n            columnData = props.data || props.array,\r\n            columnName = props.name,\r\n            columnType = props.dtype,\r\n            values = props.values || [];\r\n\r\n        var cid = attributes.indexOf(columnName);\r\n        if( cid < 0) {\r\n            attributes.push(columnName);\r\n            types.push(columnType);\r\n            configureColumn(columnName);\r\n            cid = types.length - 1;\r\n            Object.defineProperty(columns, columnName, {\r\n                get: function() { return columns[cid]; }\r\n            });\r\n        }\r\n\r\n        if(columnData instanceof ctypes[types[cid]]) {\r\n            columns[cid] = columnData;\r\n            if(values.length) {\r\n                strLists[columnName] = values;\r\n                strHashes[columnName] = {};\r\n                values.forEach(function(value, vi){\r\n                    strHashes[columnName][value] = vi;\r\n                })\r\n            }\r\n        } else if(ArrayBuffer.isView(columnData)){\r\n            columns[cid] = new colAlloc[columnName](size);\r\n            for(var di = 0; di < size; di++) {\r\n                columns[cid][di] = colRead[columnName](columnData[di]);\r\n            }\r\n        } else {\r\n            throw new Error(\"Error: Invalid data type for columnArray!\");\r\n        }\r\n        size = count = columnData.length;\r\n    }\r\n\r\n    cstore.metadata = cstore.info = function() {\r\n        return {\r\n            size: size,\r\n            count: count,\r\n            attributes: attributes,\r\n            types: types,\r\n            strLists: strLists,\r\n            strHashes: strHashes,\r\n            stats: cstore.stats()\r\n        }\r\n    }\r\n\r\n    cstore.columns = function() {\r\n        return columns;\r\n    }\r\n\r\n    cstore.data = function() {\r\n        var data = columns;\r\n        data.stats = cstore.stats();\r\n        data.keys = attributes;\r\n        data.size = size;\r\n        data.strHashes = strHashes;\r\n        data.strLists = strLists;\r\n        data.dtypes = types;\r\n        return data;\r\n    }\r\n\r\n    cstore.stats = function(col){\r\n        var col = col || attributes;\r\n        col.forEach(function(name, c){\r\n            if(!colStats[c]){\r\n                var min, max, avg;\r\n                min = max = avg = columns[c][0];\r\n\r\n                for(var i = 1; i < columns[c].length; i++){\r\n                    var d = columns[c][i];\r\n                    if(d > max) max = d;\r\n                    else if(d < min) min = d;\r\n                    avg = avg - (avg-d) / i;\r\n                }\r\n                if(max == min) max += 0.000001;\r\n                colStats[name] = {min: min, max: max, avg: avg};\r\n            }\r\n        })\r\n        return colStats;\r\n    }\r\n\r\n    cstore.domains = function(col){\r\n        var col = col || attributes,\r\n            domains = [];\r\n\r\n        col.forEach(function(name, c){\r\n            domains[name] = [colStats[name].min, colStats[name].max];\r\n        })\r\n        return domains;\r\n    }\r\n\r\n    cstore.ctypes = function() {\r\n        return ctypes;\r\n    }\r\n\r\n    cstore.size = size;\r\n\r\n    cstore.exportAsJSON = function() {\r\n        var rows = new Array(size);\r\n        for(var ri = 0; ri < size; ri++) {\r\n            var dataFrame = {};\r\n            attributes.forEach(function(attr, ai) {\r\n                if(types[ai] == 'string') {\r\n                    dataFrame[attr] = strLists[attr][columns[ai][ri]];\r\n                } else {\r\n                    dataFrame[attr] = columns[ai][ri];\r\n                }\r\n            })\r\n            rows[ri] = dataFrame;\r\n        }\r\n        return rows;\r\n    }\r\n\r\n    cstore.exportAsRowArray = function() {\r\n        var rows = new Array(size);\r\n        for(var ri = 0; ri < size; ri++) {\r\n            var row = new Array(attributes.length);\r\n            attributes.forEach(function(attr, ai) {\r\n                if(types[ai] == 'string') {\r\n                    row[ai] = strLists[attr][columns[ai][ri]];\r\n                } else {\r\n                    row[ai] = columns[ai][ri];\r\n                }\r\n            })\r\n            rows[ri] = row;\r\n        }\r\n        return rows;\r\n    }\r\n\r\n    cstore.export = function(arg) {\r\n        var format = arg || 'json';\r\n        if(format == 'rowArray') {\r\n            return cstore.exportAsRowArray();\r\n        } else {\r\n            return cstore.exportAsJSON();\r\n        }\r\n    }\r\n\r\n    cstore.import = function(arg) {\r\n        var data = arg.data || [],\r\n            schema = arg.schema || {};\r\n        size = data.length;\r\n        initStruct(schema);\r\n        initCStore();\r\n        cstore.addObjects(data);\r\n    }\r\n\r\n    return initCStore();\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/cstore.js\n// module id = 42\n// module chunks = 0","export function request(arg) {\n    var url = arg.url || arg,\n        method = arg.method || \"GET\",\n        dataType = arg.dataType || \"json\",\n        data = arg.data || [],\n        query = [];  //arraybuffer, blob, document, json, text\n\n    for (var key in data) {\n        query.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));\n    }\n\n    return new Promise(function(resolve, reject) {\n\n        var req = new XMLHttpRequest();\n        req.open(method, url);\n        req.responseType = dataType;\n\n        req.onload = function() {\n          if (req.status == 200) {\n            resolve(req.response);\n          }\n          else {\n            reject(Error(req.statusText));\n          }\n        };\n\n        req.onerror = function() {\n          reject(Error(\"Network Error\"));\n        };\n\n        if (method == 'POST') {\n            req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n        }\n\n        req.send(data);\n    });\n};\n\nexport let get = request;\n\nexport function getAll(options) {\n    var promises = [];\n    options.forEach(function(option){\n        promises.push(\n            request(option)\n            .then(function(result){\n                return new Promise(function(resolve, reject) {\n                    resolve(result);\n                });\n            })\n        );\n    });\n\n    return Promise.all(promises);\n}\n\nexport function post(arg) {\n    arg.method = \"POST\";\n    return ajax.request(arg);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ajax.js\n// module id = 43\n// module chunks = 0","export default function parse(text, delimiter) {\n    \"use strict\";\n    var size = text.length,\n        accum = 0,\n        i, //index for starting of a line\n        row,\n        rows = [],\n        fields = [],\n        lens = [],\n        EOL = false;\n\n    while(accum < size) {\n        i = accum, EOL = false;\n        row = loadLine(text, delimiter.charCodeAt(0), i);\n        rows.push(row.fields);\n        accum += row.size;\n    }\n    return rows;\n}\n\nfunction loadLine(text, delimiterCode, initPos) {\n    // if(typeof(initPos) === 'undefined') initPos = 0;\n    var EOL = false,\n        QUOTE = false,\n        c = initPos, //current pos\n        code, //code at c\n        f = initPos, // start pos of current field\n        q, //start pos of quote\n        fields = [],\n        L = text.length;\n\n    while(!EOL){\n        code = text.charCodeAt(c);\n        if(code === 10 || c>=L){\n            EOL = true;\n            // if(text.charCodeAt(c+1) === 13) ++c;\n            fields.push( text.slice(f, c) );\n        } else {\n            if(code === delimiterCode && !QUOTE) {\n                // console.log(f,c, text.slice(f, c));\n                var field = text.slice(f, c);\n                fields.push( field );\n                f = c+1;\n            } else if(code === 34){\n                if(QUOTE){\n                    if(text.charCodeAt(c+1) === delimiterCode){\n                        QUOTE = false;\n                        fields.push(text.slice(q, c));\n                        f = c+2;\n                        c++;\n                    }\n                } else {\n                    q = c+1;\n                    QUOTE = true;\n                }\n            }\n        }\n        c++;\n    }\n    return { fields: fields, size: c-initPos };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/parse.js\n// module id = 44\n// module chunks = 0"],"sourceRoot":""}